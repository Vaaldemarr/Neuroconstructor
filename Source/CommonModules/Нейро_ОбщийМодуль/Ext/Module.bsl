Функция ПолучитьОписаниеТипа_Число(Длина, Точность, Знак = Неопределено)
	Если Знак = Неопределено Тогда Знак=ДопустимыйЗнак.Любой КонецЕсли;
	КЧ = Новый КвалификаторыЧисла(Длина, Точность, Знак);			
	Массив = Новый Массив;
	Массив.Добавить(Тип("Число"));
	Возврат Новый ОписаниеТипов(Массив, , КЧ);	
КонецФункции

Функция ТолькоБуквыИЦифры(Текст) Экспорт
	Результат="";
	КодА=КодСимвола("А"); КодЯ=КодСимвола("Я"); КодА1=КодСимвола("а"); КодЯ1=КодСимвола("я");
	КодA=КодСимвола("A"); КодZ=КодСимвола("Z"); КодA1=КодСимвола("a"); КодZ1=КодСимвола("z");
	Код0=КодСимвола("0"); Код9=КодСимвола("9");
	Для Сч=1 По СтрДлина(Текст) Цикл
		СледСимвол=Сред(Текст,Сч,1); КодС=КодСимвола(СледСимвол);
		Если КодС>=КодА И КодС<=КодЯ Или КодС>=КодА1 И КодС<=КодЯ1 
			 Или КодС>=КодA И КодС<=КодZ  Или КодС>=КодA1 И КодС<=КодZ1 
			  Или КодС>=Код0 И КодС<=Код9  Или СледСимвол="_" Тогда
			 Результат=Результат+СледСимвол
		Иначе
			 Результат=Результат+"_"
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции

#Область РаботаСПеречислениями

Функция НайтиПеречислениеПоСинониму(ИмяПеречисления, ЗначениеПеречисления) Экспорт
	Текст = СокрЛП(ЗначениеПеречисления);
	Для Каждого Описание Из Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления Цикл
		Если Описание.Синоним=Текст Тогда
			Возврат Описание;
		КонецЕсли;
	КонецЦикла;
КонецФункции

Функция ПолучитьКомментарийИзЗначенияПеречисленияПоИмени(ИмяПеречисления, ИмяЗначенияПеречисления, ЗначениеПеречисления) Экспорт
	Возврат Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления[ИмяЗначенияПеречисления].Индекс(ЗначениеПеречисления).Комментарий
КонецФункции

Функция ПолучитьКомментарийИзЗначенияПеречисления(ИмяПеречисления, ЗначениеПеречисления) Экспорт
	Для Каждого Значение Из Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления Цикл
		Если ЗначениеПеречисления=Перечисления[ИмяПеречисления][Значение.Имя] Тогда
			Возврат Значение.Комментарий;
		КонецЕсли;
	КонецЦикла;
	Возврат "";
КонецФункции

Функция ПолучитьИмяИзЗначенияПеречисления(ИмяПеречисления, ЗначениеПеречисления) Экспорт
	Для Каждого Значение Из Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления Цикл
		Если ЗначениеПеречисления=Перечисления[ИмяПеречисления][Значение.Имя] Тогда
			Возврат Значение.Имя;
		КонецЕсли;
	КонецЦикла;
	Возврат "";
КонецФункции

Функция ПолучитьОписаниеТипаИзПеречисления(НейроТип) Экспорт
	Массив = Новый Массив;
	ОписаниеТипа = Неопределено;
	Если НейроТип = Перечисления.Нейро_Типы.Целое Тогда
		КЧ = Новый КвалификаторыЧисла(15,0);
		Массив.Добавить(Тип("Число"));          
		ОписаниеТипа = Новый ОписаниеТипов(Массив, , ,КЧ);
		//ОписаниеТипа = Новый ОписаниеТипов("Число");
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Вещественное Тогда
		КЧ = Новый КвалификаторыЧисла(15,6);
		Массив.Добавить(Тип("Число"));          
		ОписаниеТипа = Новый ОписаниеТипов(Массив, , ,КЧ);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ФункцияАктивации Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_ФункцииАктивации"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Булево Тогда
		Массив.Добавить(Тип("Булево"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Массив Тогда
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Строка Тогда
		КС = Новый КвалификаторыСтроки(0,ДопустимаяДлина.Переменная);
		Массив.Добавить(Тип("Строка"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив,,,,КС);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Регуляризатор Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Регуляризаторы"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Инициализатор Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Инициализаторы"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Ограничитель Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Ограничители"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ПорядокКаналов Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_ПорядокКаналов"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.VarianceScaling_Режим Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_VarianceScaling_Режим"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.VarianceScaling_Распределение Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_VarianceScaling_Распределение"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ТипNumPy Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_ТипыNumPy"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Функция Тогда
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ФункцияПотерь Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_ФункцииПотерь"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Метрика Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Метрики"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Оптимизатор Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Оптимизаторы"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Заполнение Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Padding"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ЗаполнениеСокр Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_PaddingS"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Апскейлинг Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Upscaling"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Слой Тогда
		Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_ТипыСлоев"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	КонецЕсли;	

	Возврат ОписаниеТипа;
КонецФункции

Функция ПолучитьОписанияТипаИзПеречисления(НейроТип, ИсключатьСебя=Ложь) Экспорт
	Массив = Новый Массив;
	ОписаниеТипа = Неопределено;
	Если НейроТип = Перечисления.Нейро_Типы.Целое Тогда
		КЧ = Новый КвалификаторыЧисла(15,0);
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Массив.Добавить(Тип("Число"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив, , ,КЧ);
		//ОписаниеТипа = Новый ОписаниеТипов("Число");
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Вещественное Тогда
		КЧ = Новый КвалификаторыЧисла(15,6);
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Массив.Добавить(Тип("Число"));          
		ОписаниеТипа = Новый ОписаниеТипов(Массив, , ,КЧ);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ФункцияАктивации Тогда
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_ФункцииАктивации"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Булево Тогда
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Массив.Добавить(Тип("Булево"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Массив Тогда
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Строка Тогда
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Массив.Добавить(Тип("Строка"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Регуляризатор Тогда
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Регуляризаторы"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Инициализатор Тогда
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Инициализаторы"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Ограничитель Тогда
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Ограничители"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ПорядокКаналов Тогда
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_ПорядокКаналов"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.VarianceScaling_Режим Тогда
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_VarianceScaling_Режим"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.VarianceScaling_Распределение Тогда
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_VarianceScaling_Распределение"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ТипNumPy Тогда
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_ТипыNumPy"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Функция Тогда
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
	//	Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ФункцияПотерь Тогда
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_ФункцииПотерь"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Метрика Тогда
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Метрики"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Оптимизатор Тогда
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Оптимизаторы"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Заполнение Тогда
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Padding"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ЗаполнениеСокр Тогда
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_PaddingS"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Апскейлинг Тогда
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Массивы"));          
		//Массив.Добавить(Тип("СправочникСсылка.Нейро_Функции"));          
		Если Не ИсключатьСебя Тогда
			Массив.Добавить(Тип("ПеречислениеСсылка.Нейро_Upscaling"));
		КонецЕсли;
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Слой Тогда
		Массив.Добавить(Тип("Строка"));
		ОписаниеТипа = Новый ОписаниеТипов(Массив);
	КонецЕсли;	

	Возврат ОписаниеТипа;
КонецФункции

Функция ПолучитьПараметрыИзПеречисленияТипа(НейроТип) Экспорт
	Массив = Новый Массив;
	ОписаниеТипа = Неопределено;
	Если НейроТип = Перечисления.Нейро_Типы.Целое Тогда
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Вещественное Тогда
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ФункцияАктивации Тогда
		Возврат ПолучитьПараметрыАктивации();
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Булево Тогда
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Массив Тогда
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Строка Тогда
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Регуляризатор Тогда
		Возврат ПолучитьПараметрыРегуляризации();
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Инициализатор Тогда
		Возврат ПолучитьПараметрыИнициализации()
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Ограничитель Тогда
		Возврат ПолучитьПараметрыОграничителя()
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ПорядокКаналов Тогда
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.VarianceScaling_Режим Тогда
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.VarianceScaling_Распределение Тогда
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ТипNumPy Тогда
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Функция Тогда
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.ФункцияПотерь Тогда
		Возврат ПолучитьПараметрыФункцииПотерь()
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Метрика Тогда
		Возврат ПолучитьПараметрыМетрики()
	ИначеЕсли НейроТип = Перечисления.Нейро_Типы.Оптимизатор Тогда
		Возврат ПолучитьПараметрыОптимизатора()
	КонецЕсли;	

	Возврат Неопределено;
	
КонецФункции

Функция КороткоеИмяNumPy(ЗначениеПеречисления) Экспорт
	Если ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.int8 Тогда
		Возврат "Ц8"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.int16 Тогда
		Возврат "Ц16"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.int32 Тогда
		Возврат "Ц32"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.int64 Тогда
		Возврат "Ц64"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.uint8 Тогда
		Возврат "БЦ8"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.uint16 Тогда
		Возврат "БЦ16"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.uint32 Тогда
		Возврат "БЦ32"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.uint64 Тогда
		Возврат "БЦ64"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.float16 Тогда
		Возврат "В16"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.float32 Тогда
		Возврат "В32"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.float64 Тогда
		Возврат "В64"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.complex64 Тогда
		Возврат "К64"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.complex128 Тогда
		Возврат "К128"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.bool Тогда
		Возврат "БУЛ"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.str Тогда
		Возврат "СТР"
	ИначеЕсли ЗначениеПеречисления=Перечисления.Нейро_ТипыNumPy.object Тогда
		Возврат "ОБЪЕКТ"
	КонецЕсли;
	Возврат "";
КонецФункции

Функция ПолучитьЗначениеПеречисленияПоТексту(ИмяПеречисления, Текст) Экспорт
	//Попытка
	//	Возврат Перечисления[ИмяПеречисления][Текст];
	//Исключение
	//	Возврат Неопределено
	//КонецПопытки;
	Попытка
		Возврат Перечисления[ИмяПеречисления][Текст];
	Исключение
		Возврат ПолучитьЗначениеПеречисленияПоТексту_ВстроенныйKeras(ИмяПеречисления, Текст)
	КонецПопытки;
КонецФункции

Функция ПолучитьЗначениеПеречисленияПоТексту_ВстроенныйKeras(ИмяПеречисления, Текст) Экспорт
	СоответствияKerasВерсии2=СоответствияПеречисленийKerasВерсии2(ИмяПеречисления);
	СоответствиеТекста = СоответствияKerasВерсии2.Получить(Текст);
	Если СоответствиеТекста=Неопределено Тогда Возврат Неопределено КонецЕсли;
	
	Попытка
		Возврат Перечисления[ИмяПеречисления][СоответствиеТекста];
	Исключение
		Возврат Неопределено
	КонецПопытки;
КонецФункции

Функция СоответствияПеречисленийKerasВерсии2(ИмяПеречисления) Экспорт
	Результат = Новый Соответствие;
	Если ИмяПеречисления="Нейро_ФункцииАктивации" Тогда
		//Результат.Вставить("softmax", "softmax");
		//Результат.Вставить("elu", "elu");
		//Результат.Вставить("selu", "selu");
		//Результат.Вставить("softplus", "softplus");
		//Результат.Вставить("softsign", "softsign");
		//Результат.Вставить("relu", "relu");
		//Результат.Вставить("tanh", "tanh");
		//Результат.Вставить("sigmoid", "sigmoid");
		//Результат.Вставить("hard_sigmoid", "hard_sigmoid");
		//Результат.Вставить("exponential", "exponential");
		//Результат.Вставить("linear", "linear");
		
	ИначеЕсли ИмяПеречисления="Нейро_Инициализаторы" Тогда
		Результат.Вставить("zeros_initializer", "zeros"); //tf.zeros_initializer
		Результат.Вставить("ones_initializer", "ones"); //tf.ones_initializer
		Результат.Вставить("constant_initializer", "constant"); //tf.constant_initializer
		Результат.Вставить("random_normal_initializer", "random_normal"); //tf.random_normal_initializer
		Результат.Вставить("random_uniform_initializer", "random_uniform"); //tf.random_uniform_initializer
		Результат.Вставить("TruncatedNormal", "truncated_normal");
		//Результат.Вставить("VarianceScaling", "VarianceScaling");
		Результат.Вставить("Orthogonal", "orthogonal");
		//Результат.Вставить("Identity", "Identity");
		//Результат.Вставить("lecun_uniform", "lecun_uniform");
		Результат.Вставить("GlorotNormal", "glorot_normal");
		Результат.Вставить("GlorotUniform", "glorot_uniform");
		//Результат.Вставить("he_normal", "he_normal");
		//Результат.Вставить("lecun_normal", "lecun_normal");
		//Результат.Вставить("he_uniform", "he_uniform");
		
		Для Каждого Описание Из Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления Цикл
			МассивИд = СтрРазделить(Описание.Комментарий,".",Ложь);
			Если МассивИд.Количество()>0 Тогда
				Результат.Вставить(МассивИд[МассивИд.Количество()-1], Описание.Имя);
			КонецЕсли;
		КонецЦикла;
		
	//ИначеЕсли ИмяПеречисления="Нейро_VarianceScaling_Режим" Тогда
	//	Результат.Вставить("", "fan_in");
	//	Результат.Вставить("", "fan_out");
	//	Результат.Вставить("", "fan_avg");
		
	//ИначеЕсли ИмяПеречисления="Нейро_VarianceScaling_Распределение" Тогда
	//	Результат.Вставить("", "normal");
	//	Результат.Вставить("", "uniform");
	//	Результат.Вставить("", "truncated_normal");
	//	Результат.Вставить("", "untruncated_normal");
		
	ИначеЕсли ИмяПеречисления="Нейро_Регуляризаторы" Тогда
		//Результат.Вставить("", "l1");
		//Результат.Вставить("", "l2");
		//Результат.Вставить("", "l1_l2");
		Результат.Вставить("L1L2", "l1_l2");
		
	ИначеЕсли ИмяПеречисления="Нейро_Ограничители" Тогда
		Результат.Вставить("MaxNorm", "max_norm");
		Результат.Вставить("NonNeg", "non_neg");
		Результат.Вставить("UnitNorm", "unit_norm");
		Результат.Вставить("MinMaxNorm", "min_max_norm");
		//Результат.Вставить("", "RadialConstraint");
		
		Для Каждого Описание Из Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления Цикл
			МассивИд = СтрРазделить(Описание.Комментарий,".",Ложь);
			Если МассивИд.Количество()>0 Тогда
				Результат.Вставить(МассивИд[МассивИд.Количество()-1], Описание.Имя);
			КонецЕсли;
		КонецЦикла;
		
	//ИначеЕсли ИмяПеречисления="Нейро_ПорядокКаналов" Тогда
	//	Результат.Вставить("", "");
		
	ИначеЕсли ИмяПеречисления="Нейро_ФункцииПотерь" Тогда
		Результат.Вставить("MSE", "mean_squared_error");
		Результат.Вставить("MAE", "mean_absolute_error");
		Результат.Вставить("MAPE", "mean_absolute_percentage_error");
		Результат.Вставить("MSLE", "mean_squared_logarithmic_error");
		//Результат.Вставить("", "squared_hinge");
		//Результат.Вставить("", "hinge");
		//Результат.Вставить("", "categorical_hinge");
		//Результат.Вставить("", "logcosh");
		//Результат.Вставить("", "categorical_crossentropy");
		//Результат.Вставить("", "sparse_categorical_crossentropy");
		//Результат.Вставить("", "binary_crossentropy");
		Результат.Вставить("KLD", "kullback_leibler_divergence");
		//Результат.Вставить("", "poisson");
		Результат.Вставить("cosine_similarity", "cosine_proximity");
		
		Для Каждого Описание Из Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления Цикл
			МассивИд = СтрРазделить(Описание.Комментарий,".",Ложь);
			Если МассивИд.Количество()>0 Тогда
				Результат.Вставить(МассивИд[МассивИд.Количество()-1], Описание.Имя);
			КонецЕсли;
		КонецЦикла;
		
	ИначеЕсли ИмяПеречисления="Нейро_Метрики" Тогда
		//Результат.Вставить("", "accuracy");
		//Результат.Вставить("", "crossentropy");
		//Результат.Вставить("", "binary_accuracy");
		//Результат.Вставить("", "categorical_accuracy");
		//Результат.Вставить("", "sparse_categorical_accuracy");
		//Результат.Вставить("", "top_k_categorical_accuracy");
		//Результат.Вставить("", "sparse_top_k_categorical_accuracy");
		Результат.Вставить("CosineSimilarity", "cosine_proximity");
		
		Для Каждого Описание Из Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления Цикл
			МассивИд = СтрРазделить(Описание.Комментарий,".",Ложь);
			Если МассивИд.Количество()>0 Тогда
				Результат.Вставить(МассивИд[МассивИд.Количество()-1], Описание.Имя);
			КонецЕсли;
		КонецЦикла;
		
	//ИначеЕсли ИмяПеречисления="Нейро_Оптимизаторы" Тогда
		//Результат.Вставить("", "SGD");
		//Результат.Вставить("", "RMSprop");
		//Результат.Вставить("", "Adagrad");
		//Результат.Вставить("", "Adadelta");
		//Результат.Вставить("", "Adam");
		//Результат.Вставить("", "Adamax");
		//Результат.Вставить("", "Nadam");
		//Результат.Вставить("", "Ftrl");
		
	//ИначеЕсли ИмяПеречисления="Нейро_Padding" Тогда
	//	Результат.Вставить("", "");
	//	
	//ИначеЕсли ИмяПеречисления="Нейро_PaddingS" Тогда
	//	Результат.Вставить("", "");
	//	
	//ИначеЕсли ИмяПеречисления="Нейро_Upscaling" Тогда
	//	Результат.Вставить("", "");
	//	
	//ИначеЕсли ИмяПеречисления="Нейро_ТекстВКатегорииРежим" Тогда
	//	Результат.Вставить("", "");
	//	
	//ИначеЕсли ИмяПеречисления="Нейро_СтандартныеМетрики" Тогда
	//	Результат.Вставить("", "");
	//	
	//ИначеЕсли ИмяПеречисления="Нейро_РежимСамоконтроля" Тогда
	//	Результат.Вставить("", "");
		
	КонецЕсли;

	Возврат Результат
КонецФункции

Функция НайтиПеречислениеПоТекстуСинонима(ИмяПеречисления, Текст) Экспорт
	Для Каждого Описание Из Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления Цикл
		Если Описание.Синоним=Текст Тогда
			Возврат Перечисления[ИмяПеречисления][Описание.Имя]
		КонецЕсли;
	КонецЦикла;
КонецФункции

Функция СтрокаТипаИзDescrNPY(Описание) Экспорт
	Если Описание="|i1" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.int8
	ИначеЕсли Описание="<i2" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.int16
	ИначеЕсли Описание="<i4" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.int32
	ИначеЕсли Описание="<i8" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.int64
	ИначеЕсли Описание="|u1" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.uint8
	ИначеЕсли Описание="<u2" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.uint16
	ИначеЕсли Описание="<u4" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.uint32
	ИначеЕсли Описание="<u8" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.uint64
	ИначеЕсли Описание="<f2" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.float16
	ИначеЕсли Описание="<f4" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.float32
	ИначеЕсли Описание="<f8" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.float64
	ИначеЕсли Описание="<c8" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.complex64
	ИначеЕсли Описание="<c16" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.complex128
	ИначеЕсли Описание="|b1" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.bool
	ИначеЕсли Описание="<U0" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.str
	ИначеЕсли Описание="|O" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.object
	ИначеЕсли Описание="|S0" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.string_
	ИначеЕсли Лев(Описание,2)="|S" Тогда
		Возврат Перечисления.Нейро_ТипыNumPy.string_
	КонецЕсли;

	Возврат Перечисления.Нейро_ТипыNumPy.ПустаяСсылка();
КонецФункции

Функция ПолучитьКороткийФорматNumpyПоТипу(ТипNumpy) Экспорт
	Если ТипNumpy = Перечисления.Нейро_ТипыNumPy.int8 Тогда
		Возврат "%d"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.int16 Тогда
		Возврат "%d"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.int32 Тогда
		Возврат "%d"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.int64 Тогда
		Возврат "%d"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.uint8 Тогда
		Возврат "%u"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.uint16 Тогда
		Возврат "%u"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.uint32 Тогда
		Возврат "%u"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.uint64 Тогда
		Возврат "%u"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.float16 Тогда
		Возврат "%f"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.float32 Тогда
		Возврат "%f"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.float64 Тогда
		Возврат "%f"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.complex64 Тогда
		Возврат "%s"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.complex128 Тогда
		Возврат "%s"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.bool Тогда
		Возврат "%s"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.str Тогда
		Возврат "%s"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.string_ Тогда
		Возврат "%s"
	ИначеЕсли ТипNumpy = Перечисления.Нейро_ТипыNumPy.object Тогда
		Возврат "%s"
	Иначе
		Возврат "%s"
	КонецЕсли;
КонецФункции	

Функция ПолучитьСсылкуНаОписаниеСлоя(ТипСлоя) Экспорт

	Если ТипСлоя = Перечисления.Нейро_ТипыСлоев.InputLayer Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/InputLayer"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Activation Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Activation"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.ActivityRegularization Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/ActivityRegularization"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Add Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Add"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.AlphaDropout Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/AlphaDropout"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Average Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Average"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.AveragePooling1D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/AveragePooling1D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.AveragePooling2D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/AveragePooling2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.AveragePooling3D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/AveragePooling3D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.BatchNormalization Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/BatchNormalization"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Bidirectional Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Bidirectional"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Concatenate Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Concatenate"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Conv1D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Conv1D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Conv2D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Conv2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Conv2DTranspose Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Conv2DTranspose"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Conv3D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Conv3D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Conv3DTranspose Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Conv3DTranspose"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.ConvLSTM2D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/ConvLSTM2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.ConvLSTM2DCell Тогда
		Возврат ""
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Cropping1D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Cropping1D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Cropping2D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Cropping2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Cropping3D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Cropping3D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.CuDNNGRU Тогда
		Возврат ""
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.CuDNNLSTM Тогда
		Возврат ""
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Dense Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Dense"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.DepthwiseConv2D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/DepthwiseConv2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Dot Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Dot"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Dropout Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Dropout"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.ELU Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/ELU"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Embedding Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Embedding"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Flatten Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Flatten"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.GaussianDropout Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/GaussianDropout"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.GaussianNoise Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/GaussianNoise"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.GlobalAveragePooling1D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/GlobalAveragePooling1D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.GlobalAveragePooling2D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/GlobalAveragePooling2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.GlobalAveragePooling3D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/GlobalAveragePooling3D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.GlobalMaxPooling1D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/GlobalMaxPool1D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.GlobalMaxPooling2D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/GlobalMaxPool2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.GlobalMaxPooling3D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/GlobalMaxPool3D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.GRU Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/GRU"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.GRUCell Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/GRUCell"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.LeakyReLU Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/LeakyReLU"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.LocallyConnected1D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/LocallyConnected1D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.LocallyConnected2D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/LocallyConnected2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.LSTM Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/LSTM"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.LSTMCell Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/LSTMCell"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Masking Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Masking"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Maximum Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Maximum"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.MaxPooling1D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/MaxPool1D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.MaxPooling2D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/MaxPool2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.MaxPooling3D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/MaxPool3D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Minimum Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Minimum"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Multiply Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Multiply"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Permute Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Permute"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.PReLU Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/PReLU"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.ReLU Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/ReLU"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.RepeatVector Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/RepeatVector"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Reshape Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Reshape"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.SeparableConv1D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/SeparableConv1D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.SeparableConv2D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/SeparableConv2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.SimpleRNN Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/SimpleRNN"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.SimpleRNNCell Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/SimpleRNNCell"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Softmax Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Softmax"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.SpatialDropout1D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/SpatialDropout1D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.SpatialDropout2D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/SpatialDropout2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.SpatialDropout3D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/SpatialDropout3D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Subtract Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/Subtract"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.ThresholdedReLU Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/ThresholdedReLU"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.TimeDistributed Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/TimeDistributed"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.UpSampling1D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/UpSampling1D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.UpSampling2D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/UpSampling2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.UpSampling3D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/UpSampling2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.ZeroPadding1D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/ZeroPadding1D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.ZeroPadding2D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/ZeroPadding2D"
	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.ZeroPadding3D Тогда
		Возврат "https://www.tensorflow.org/api_docs/python/tf/keras/layers/ZeroPadding3D"
	КонецЕсли;
	
КонецФункции
	
#КонецОбласти

//Функция ИдСлоя(ТипСлоя) Экспорт
//	Если ТипСлоя = Перечисления.Нейро_ТипыСлоев.Входной Тогда
//		Возврат "keras.engine.input_layer.Input"
//	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Полносвязный Тогда
//		Возврат "keras.layers.Dense"
//	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Активация Тогда
//		Возврат "keras.layers.Activation"
//	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Прореживание Тогда
//		Возврат "keras.layers.Dropout"
//	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Плоский Тогда
//		Возврат "keras.layers.Flatten"
//	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Переформирование Тогда
//		Возврат "keras.layers.Reshape"
//	ИначеЕсли ТипСлоя = Перечисления.Нейро_ТипыСлоев.Перестановка Тогда
//		Возврат "keras.layers.Permute"
//	КонецЕсли;
//КонецФункции

#Область ПараметрыСлоев

Функция ПолучитьПараметрыСлоя(ТипСлоя) Экспорт
	Результат = Новый Массив;
	ПараметрСлоя = Новый Структура;
	
	ТипСтрока        = Перечисления.Нейро_Типы.Строка;
	ТипЦелое         = Перечисления.Нейро_Типы.Целое;
	ТипВещественное  = Перечисления.Нейро_Типы.Вещественное;
	ТипБулево        = Перечисления.Нейро_Типы.Булево;
	ТипМассив        = Перечисления.Нейро_Типы.Массив;
	ТипАктивация     = Перечисления.Нейро_Типы.ФункцияАктивации;
	ТипИнициализация = Перечисления.Нейро_Типы.Инициализатор;
	ТипРегуляризация = Перечисления.Нейро_Типы.Регуляризатор;
	ТипОграничитель  = Перечисления.Нейро_Типы.Ограничитель;
	
	ТипЗаполнение    = Перечисления.Нейро_Типы.Заполнение;
	ТипЗаполнениеСокр= Перечисления.Нейро_Типы.ЗаполнениеСокр;
	ТипПорядокКаналов= Перечисления.Нейро_Типы.ПорядокКаналов;
	ТипАпскейлинг    = Перечисления.Нейро_Типы.Апскейлинг;
	
		//Результат.Добавить(Новый Структура("Рус, Анг, Тип","","", Тип("");
	Если ТипСлоя=Перечисления.Нейро_ТипыСлоев.InputLayer Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Форма","shape", ТипМассив, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Пакетная форма","batch_shape", ТипМассив, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Имя","name", ТипСтрока, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Тип","dtype", Перечисления.Нейро_Типы.ТипNumPy, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Разреженный","sparse", ТипБулево, "", Новый Массив));
		//Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Тензор","tensor", Перечисления.Нейро_Типы.Тензор, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Dense Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Нейронов","units", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Activation Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		//Результат = ПолучитьПараметрыАктивации();
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Dropout Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Доля прореживания","rate", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Измерения маски шума","noise_shape", ТипМассив, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор ГСЧ","seed", ТипЦелое, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Permute Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Измерения","dims", ТипМассив, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.RepeatVector Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Коэффициент повторения","n", ТипЦелое, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.ActivityRegularization Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Коэффициент регуляризации L1","l1", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Коэффициент регуляризации L2","l2", ТипВещественное, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Masking Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Значение маски","mask_value", ТипВещественное, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.SpatialDropout1D Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Доля прореживания","rate", ТипВещественное, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.SpatialDropout2D Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Доля прореживания","rate", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.SpatialDropout3D Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Доля прореживания","rate", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Reshape Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Измерения","dims", ТипМассив, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Flatten Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", Перечисления.Нейро_Типы.ПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Concatenate Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ось","axis", ТипЦелое, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Dot Тогда
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Оси","axes", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Нормализовать","normalize", ТипБулево, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Conv1D Тогда
		//keras.layers.Conv1D(filters, kernel_size, strides=1, padding='valid', data_format='channels_last', dilation_rate=1, activation=None, use_bias=True, kernel_initializer='glorot_uniform', bias_initializer='zeros', kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Фильтры","filters", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","kernel_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ширина шагов","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнение, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Скорость расширения","dilation_rate", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Conv2D Тогда
		//keras.layers.Conv2D(filters, kernel_size, strides=(1, 1), padding='valid', data_format=None, dilation_rate=(1, 1), activation=None, use_bias=True, kernel_initializer='glorot_uniform', bias_initializer='zeros', kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Фильтры","filters", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","kernel_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ширина шагов","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Скорость расширения","dilation_rate", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.SeparableConv1D Тогда
		//keras.layers.SeparableConv1D(filters, kernel_size, strides=1, padding='valid', data_format='channels_last', dilation_rate=1, depth_multiplier=1, activation=None, use_bias=True, depthwise_initializer='glorot_uniform', pointwise_initializer='glorot_uniform', bias_initializer='zeros', depthwise_regularizer=None, pointwise_regularizer=None, bias_regularizer=None, activity_regularizer=None, depthwise_constraint=None, pointwise_constraint=None, bias_constraint=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Фильтры","filters", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","kernel_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ширина шагов","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Скорость расширения","dilation_rate", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Множитель по глубине","depth_multiplier", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов по глубине","depthwise_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов точечный","pointwise_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов по глубине","depthwise_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов точечный","pointwise_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов по глубине","depthwise_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов точечное","pointwise_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.SeparableConv2D Тогда
		//keras.layers.SeparableConv2D(filters, kernel_size, strides=(1, 1), padding='valid', data_format=None, dilation_rate=(1, 1), depth_multiplier=1, activation=None, use_bias=True, depthwise_initializer='glorot_uniform', pointwise_initializer='glorot_uniform', bias_initializer='zeros', depthwise_regularizer=None, pointwise_regularizer=None, bias_regularizer=None, activity_regularizer=None, depthwise_constraint=None, pointwise_constraint=None, bias_constraint=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Фильтры","filters", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","kernel_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ширина шагов","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Скорость расширения","dilation_rate", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Множитель по глубине","depth_multiplier", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов по глубине","depthwise_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов точечный","pointwise_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов по глубине","depthwise_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов точечный","pointwise_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов по глубине","depthwise_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов точечное","pointwise_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.DepthwiseConv2D Тогда
		//keras.layers.DepthwiseConv2D(kernel_size, strides=(1, 1), padding='valid', depth_multiplier=1, data_format=None, activation=None, use_bias=True, depthwise_initializer='glorot_uniform', bias_initializer='zeros', depthwise_regularizer=None, bias_regularizer=None, activity_regularizer=None, depthwise_constraint=None, bias_constraint=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","kernel_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ширина шагов","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Множитель по глубине","depth_multiplier", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов по глубине","depthwise_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов по глубине","depthwise_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов по глубине","depthwise_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Conv2DTranspose Тогда
		//keras.layers.Conv2DTranspose(filters, kernel_size, strides=(1, 1), padding='valid', output_padding=None, data_format=None, dilation_rate=(1, 1), activation=None, use_bias=True, kernel_initializer='glorot_uniform', bias_initializer='zeros', kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Фильтры","filters", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","kernel_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ширина шагов","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Выходное дополнение","output_padding", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Скорость расширения","dilation_rate", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Conv3D Тогда
		//keras.layers.Conv3D(filters, kernel_size, strides=(1, 1, 1), padding='valid', data_format=None, dilation_rate=(1, 1, 1), activation=None, use_bias=True, kernel_initializer='glorot_uniform', bias_initializer='zeros', kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Фильтры","filters", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","kernel_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ширина шагов","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Скорость расширения","dilation_rate", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Conv3DTranspose Тогда
		//keras.layers.Conv3DTranspose(filters, kernel_size, strides=(1, 1, 1), padding='valid', output_padding=None, data_format=None, activation=None, use_bias=True, kernel_initializer='glorot_uniform', bias_initializer='zeros', kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Фильтры","filters", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","kernel_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ширина шагов","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Выходное дополнение","output_padding", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Скорость расширения","dilation_rate", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Cropping1D Тогда
		//keras.layers.Cropping1D(cropping=(1, 1))
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Обрезать","cropping", ТипЦелое, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Cropping2D Тогда
		//keras.layers.Cropping2D(cropping=((0, 0), (0, 0)), data_format=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Обрезать","cropping", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Cropping3D Тогда
		//keras.layers.Cropping3D(cropping=((1, 1), (1, 1), (1, 1)), data_format=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Обрезать","cropping", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.UpSampling1D Тогда
		//keras.layers.UpSampling1D(size=2)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Коэфф. размножения","size", ТипЦелое, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.UpSampling2D Тогда
		//keras.layers.UpSampling2D(size=(2, 2), data_format=None, interpolation='nearest')
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Коэфф. размножения","size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Интерполяция","interpolation", ТипАпскейлинг, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.UpSampling3D Тогда
		//keras.layers.UpSampling3D(size=(2, 2, 2), data_format=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Коэфф. размножения","size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.ZeroPadding1D Тогда
		//keras.layers.ZeroPadding1D(padding=1)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.ZeroPadding2D Тогда
		//keras.layers.ZeroPadding2D(padding=(1, 1), data_format=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.ZeroPadding3D Тогда
		//keras.layers.ZeroPadding3D(padding=(1, 1, 1), data_format=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.MaxPooling1D Тогда
		//keras.layers.MaxPooling1D(pool_size=2, strides=None, padding='valid', data_format='channels_last')
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","pool_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Шаг делителя","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.MaxPooling2D Тогда
		//keras.layers.MaxPooling2D(pool_size=(2, 2), strides=None, padding='valid', data_format=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","pool_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Шаг делителя","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.MaxPooling3D Тогда
		//keras.layers.MaxPooling3D(pool_size=(2, 2, 2), strides=None, padding='valid', data_format=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","pool_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Шаг делителя","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.AveragePooling1D Тогда
		//keras.layers.AveragePooling1D(pool_size=2, strides=None, padding='valid', data_format='channels_last')
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","pool_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Шаг делителя","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.AveragePooling2D Тогда
		//keras.layers.AveragePooling2D(pool_size=(2, 2), strides=None, padding='valid', data_format=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","pool_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Шаг делителя","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.AveragePooling3D Тогда
		//keras.layers.AveragePooling3D(pool_size=(2, 2, 2), strides=None, padding='valid', data_format=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","pool_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Шаг делителя","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.GlobalMaxPooling1D Тогда
		//keras.layers.GlobalMaxPooling1D(data_format='channels_last')
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.GlobalAveragePooling1D Тогда
		//keras.layers.GlobalAveragePooling1D(data_format='channels_last')
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.GlobalMaxPooling2D Тогда
		//keras.layers.GlobalMaxPooling2D(data_format=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.GlobalAveragePooling2D Тогда
		//keras.layers.GlobalAveragePooling2D(data_format=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.GlobalMaxPooling3D Тогда
		//keras.layers.GlobalMaxPooling3D(data_format=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.GlobalAveragePooling3D Тогда
		//keras.layers.GlobalAveragePooling3D(data_format=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.LocallyConnected1D Тогда
		//keras.layers.LocallyConnected1D(filters, kernel_size, strides=1, padding='valid', data_format=None, activation=None, use_bias=True, kernel_initializer='glorot_uniform', bias_initializer='zeros', kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Фильтры","filters", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","kernel_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ширина шагов","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.LocallyConnected2D Тогда
		//keras.layers.LocallyConnected2D(filters, kernel_size, strides=(1, 1), padding='valid', data_format=None, activation=None, use_bias=True, kernel_initializer='glorot_uniform', bias_initializer='zeros', kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Фильтры","filters", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","kernel_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ширина шагов","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.SimpleRNN Тогда
		//keras.layers.SimpleRNN(units, activation='tanh', use_bias=True, kernel_initializer='glorot_uniform', recurrent_initializer='orthogonal', bias_initializer='zeros', kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, dropout=0.0, recurrent_dropout=0.0, return_sequences=False, return_state=False, go_backwards=False, stateful=False, unroll=False)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Блоки","units", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный инициализатор","recurrent_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный регуляризатор","recurrent_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное ограничение весов","recurrent_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Прореживание","dropout", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное прореживание","recurrent_dropout", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Возвращать последовательности","return_sequences", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Возвращать состояние","return_state", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","В обратном направлении ","go_backwards", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать предыдущее состояние","stateful", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Развертывать","unroll", ТипБулево, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.GRU Тогда
		//keras.layers.GRU(units, activation='tanh', recurrent_activation='hard_sigmoid', use_bias=True, kernel_initializer='glorot_uniform', recurrent_initializer='orthogonal', bias_initializer='zeros', kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, dropout=0.0, recurrent_dropout=0.0, implementation=1, return_sequences=False, return_state=False, go_backwards=False, stateful=False, unroll=False, reset_after=False)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Блоки","units", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентная активация","recurrent_activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный инициализатор","recurrent_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный регуляризатор","recurrent_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное ограничение весов","recurrent_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Прореживание","dropout", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное прореживание","recurrent_dropout", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Режим реализации","implementation", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Возвращать последовательности","return_sequences", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Возвращать состояние","return_state", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","В обратном направлении ","go_backwards", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать предыдущее состояние","stateful", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Развертывать","unroll", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Сброс после умножения","reset_after", ТипБулево, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.LSTM Тогда
		//keras.layers.LSTM(units, activation='tanh', recurrent_activation='hard_sigmoid', use_bias=True, kernel_initializer='glorot_uniform', recurrent_initializer='orthogonal', bias_initializer='zeros', unit_forget_bias=True, kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, dropout=0.0, recurrent_dropout=0.0, implementation=1, return_sequences=False, return_state=False, go_backwards=False, stateful=False, unroll=False)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Блоки","units", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентная активация","recurrent_activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный инициализатор","recurrent_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Блок забывает смещение","unit_forget_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный регуляризатор","recurrent_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное ограничение весов","recurrent_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Прореживание","dropout", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное прореживание","recurrent_dropout", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Режим реализации","implementation", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Возвращать последовательности","return_sequences", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Возвращать состояние","return_state", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","В обратном направлении ","go_backwards", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать предыдущее состояние","stateful", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Развертывать","unroll", ТипБулево, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.ConvLSTM2D Тогда
		//keras.layers.ConvLSTM2D(filters, kernel_size, strides=(1, 1), padding='valid', data_format=None, dilation_rate=(1, 1), activation='tanh', recurrent_activation='hard_sigmoid', use_bias=True, kernel_initializer='glorot_uniform', recurrent_initializer='orthogonal', bias_initializer='zeros', unit_forget_bias=True, kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, return_sequences=False, go_backwards=False, stateful=False, dropout=0.0, recurrent_dropout=0.0)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Фильтры","filters", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","kernel_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ширина шагов","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Скорость расширения","dilation_rate", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентная активация","recurrent_activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный инициализатор","recurrent_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Блок забывает смещение","unit_forget_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный регуляризатор","recurrent_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное ограничение весов","recurrent_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Возвращать последовательности","return_sequences", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","В обратном направлении ","go_backwards", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать предыдущее состояние","stateful", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Прореживание","dropout", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное прореживание","recurrent_dropout", ТипВещественное, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.ConvLSTM2DCell Тогда
		//keras.layers.ConvLSTM2DCell(filters, kernel_size, strides=(1, 1), padding='valid', data_format=None, dilation_rate=(1, 1), activation='tanh', recurrent_activation='hard_sigmoid', use_bias=True, kernel_initializer='glorot_uniform', recurrent_initializer='orthogonal', bias_initializer='zeros', unit_forget_bias=True, kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, dropout=0.0, recurrent_dropout=0.0)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Фильтры","filters", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Размер кадра","kernel_size", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ширина шагов","strides", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Способ дополнения","padding", ТипЗаполнениеСокр, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Формат данных","data_format", ТипПорядокКаналов, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Скорость расширения","dilation_rate", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентная активация","recurrent_activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный инициализатор","recurrent_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Блок забывает смещение","unit_forget_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный регуляризатор","recurrent_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное ограничение весов","recurrent_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Прореживание","dropout", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное прореживание","recurrent_dropout", ТипВещественное, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.SimpleRNNCell Тогда
		//keras.layers.SimpleRNNCell(units, activation='tanh', use_bias=True, kernel_initializer='glorot_uniform', recurrent_initializer='orthogonal', bias_initializer='zeros', kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, dropout=0.0, recurrent_dropout=0.0)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Блоки","units", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный инициализатор","recurrent_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный регуляризатор","recurrent_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное ограничение весов","recurrent_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Прореживание","dropout", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное прореживание","recurrent_dropout", ТипВещественное, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.GRUCell Тогда
		//keras.layers.GRUCell(units, activation='tanh', recurrent_activation='hard_sigmoid', use_bias=True, kernel_initializer='glorot_uniform', recurrent_initializer='orthogonal', bias_initializer='zeros', kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, dropout=0.0, recurrent_dropout=0.0, implementation=1, reset_after=False)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Блоки","units", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентная активация","recurrent_activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный инициализатор","recurrent_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный регуляризатор","recurrent_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное ограничение весов","recurrent_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Прореживание","dropout", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное прореживание","recurrent_dropout", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Режим реализации","implementation", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Сброс после умножения","reset_after", ТипБулево, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.LSTMCell Тогда
		//keras.layers.LSTMCell(units, activation='tanh', recurrent_activation='hard_sigmoid', use_bias=True, kernel_initializer='glorot_uniform', recurrent_initializer='orthogonal', bias_initializer='zeros', unit_forget_bias=True, kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, dropout=0.0, recurrent_dropout=0.0, implementation=1)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Блоки","units", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Активация","activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентная активация","recurrent_activation", ТипАктивация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать смещение","use_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный инициализатор","recurrent_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Блок забывает смещение","unit_forget_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный регуляризатор","recurrent_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное ограничение весов","recurrent_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Прореживание","dropout", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное прореживание","recurrent_dropout", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Режим реализации","implementation", ТипВещественное, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.CuDNNGRU Тогда
		//keras.layers.CuDNNGRU(units, kernel_initializer='glorot_uniform', recurrent_initializer='orthogonal', bias_initializer='zeros', kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, return_sequences=False, return_state=False, stateful=False)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Блоки","units", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный инициализатор","recurrent_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный регуляризатор","recurrent_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное ограничение весов","recurrent_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Возвращать последовательности","return_sequences", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Возвращать состояние","return_state", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать предыдущее состояние","stateful", ТипБулево, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.CuDNNLSTM Тогда
		//keras.layers.CuDNNLSTM(units, kernel_initializer='glorot_uniform', recurrent_initializer='orthogonal', bias_initializer='zeros', unit_forget_bias=True, kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, return_sequences=False, return_state=False, stateful=False)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Блоки","units", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор весов","kernel_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный инициализатор","recurrent_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор смещения","bias_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Блок забывает смещение","unit_forget_bias", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор весов","kernel_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентный регуляризатор","recurrent_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор смещения","bias_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение весов","kernel_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Рекуррентное ограничение весов","recurrent_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение смещения","bias_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Возвращать последовательности","return_sequences", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Возвращать состояние","return_state", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Использовать предыдущее состояние","stateful", ТипБулево, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Embedding Тогда
		//keras.layers.Embedding(input_dim, output_dim, embeddings_initializer='uniform', embeddings_regularizer=None, activity_regularizer=None, embeddings_constraint=None, mask_zero=False, input_length=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Входное разрешение","input_dim", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Выходное разрешение","output_dim", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор погружения","embeddings_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор погружения","embeddings_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Регуляризатор активации","activity_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ограничение погружения","embeddings_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Маскировать нули","mask_zero", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Входная длина","input_length", ТипЦелое, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.LeakyReLU Тогда
		//keras.layers.LeakyReLU(alpha=0.3)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Альфа","alpha", ТипВещественное, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.PReLU Тогда
		//keras.layers.PReLU(alpha_initializer='zeros', alpha_regularizer=None, alpha_constraint=None, shared_axes=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Альфа инициализатор","alpha_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Альфа регуляризатор","alpha_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Альфа ограничитель","alpha_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Общие оси","shared_axes", ТипЦелое, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.ELU Тогда
		//keras.layers.ELU(alpha=1.0)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Альфа","alpha", ТипВещественное, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.ThresholdedReLU Тогда
		//keras.layers.ThresholdedReLU(theta=1.0)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Тета","theta", ТипВещественное, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Softmax Тогда
		//keras.layers.Softmax(axis=-1)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ось","axis", ТипЦелое, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.ReLU Тогда
		//keras.layers.ReLU(max_value=None, negative_slope=0.0, threshold=0.0)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Максимальное значение","max_value", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Отрицательный наклон","negative_slope", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Порог","threshold", ТипВещественное, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.BatchNormalization Тогда
		//keras.layers.BatchNormalization(axis=-1, momentum=0.99, epsilon=0.001, center=True, scale=True, beta_initializer='zeros', gamma_initializer='ones', moving_mean_initializer='zeros', moving_variance_initializer='ones', beta_regularizer=None, gamma_regularizer=None, beta_constraint=None, gamma_constraint=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Ось","axis", ТипЦелое, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Импульс","momentum", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Эпсилон","epsilon", ТипВещественное, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Центрировать","center", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Масштабировать","scale", ТипБулево, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Бета инициализатор","beta_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Гамма инициализатор","gamma_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор математического ожидания","moving_mean_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Инициализатор дисперсии","moving_variance_initializer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Бета инициализатор","beta_regularizer", ТипИнициализация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Гамма регуляризатор","gamma_regularizer", ТипРегуляризация, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Бета ограничитель","beta_constraint", ТипОграничитель, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Гамма ограничитель","gamma_constraint", ТипОграничитель, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.GaussianNoise Тогда
		//keras.layers.GaussianNoise(stddev)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Стандартное отклонение","stddev", ТипВещественное, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.GaussianDropout Тогда
		//keras.layers.GaussianDropout(rate)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Темп","rate", ТипВещественное, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.AlphaDropout Тогда
		//keras.layers.AlphaDropout(rate, noise_shape=None, seed=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Темп","rate", ТипВещественное, "", Новый Массив));
		//Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Форма шума","noise_shape", Перечисления.Нейро_Типы.Тензор, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Заполнение","seed", ТипЦелое, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.TimeDistributed Тогда
		//keras.layers.TimeDistributed(layer)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Слой","layer", Перечисления.Нейро_Типы.Слой, "", Новый Массив));
	ИначеЕсли ТипСлоя=Перечисления.Нейро_ТипыСлоев.Bidirectional Тогда
		//keras.layers.Bidirectional(layer, merge_mode='concat', weights=None)
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Слой","layer", Перечисления.Нейро_Типы.Слой, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Режим слияния","merge_mode", ТипСтрока, "", Новый Массив));
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, ИдОбъекта, Доп","Веса","weights", ТипМассив, "", Новый Массив));
	КонецЕсли;
	
	Возврат Результат
КонецФункции

Функция ПолучитьПараметрыАктивации() Экспорт
	Результат = Новый Массив;

	ТипСтрока       = Перечисления.Нейро_Типы.Строка;
	ТипЦелое        = Перечисления.Нейро_Типы.Целое;
	ТипВещественное = Перечисления.Нейро_Типы.Вещественное;
	ТипАктивация    = Перечисления.Нейро_Типы.ФункцияАктивации;
	ТипБулево       = Перечисления.Нейро_Типы.ФункцияАктивации;
	
	АдресГруппы = "keras/activations/";
	
	Для Сч = 0 По Метаданные.Перечисления.Нейро_ФункцииАктивации.ЗначенияПеречисления.Количество()-1 Цикл
		ИдОбъекта = ""; АдресОбъекта = "";
		Значение=Метаданные.Перечисления.Нейро_ФункцииАктивации.ЗначенияПеречисления[Сч];
		МассивДоп=Новый Массив;
		Если Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииАктивации.softmax) Тогда
			АдресОбъекта = "softmax";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Ось";
			ПараметрыПараметра.Анг = "axis";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.activations.softmax";
			Объект = Перечисления.Нейро_ФункцииАктивации.softmax;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииАктивации.elu) Тогда
			АдресОбъекта = "elu";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Альфа";
			ПараметрыПараметра.Анг = "alpha";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.activations.elu";
			Объект = Перечисления.Нейро_ФункцииАктивации.elu;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииАктивации.selu) Тогда
			АдресОбъекта = "selu";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "x";
			ПараметрыПараметра.Анг = "x";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.activations.selu";
			Объект = Перечисления.Нейро_ФункцииАктивации.selu;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииАктивации.softplus) Тогда
			АдресОбъекта = "softplus";
			//ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			//ПараметрыПараметра.Рус = "x";
			//ПараметрыПараметра.Анг = "x";
			//ПараметрыПараметра.Тип = ТипВещественное;
			//МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.activations.softplus";
			Объект = Перечисления.Нейро_ФункцииАктивации.softplus;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииАктивации.softsign) Тогда
			АдресОбъекта = "softsign";
			//ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			//ПараметрыПараметра.Рус = "x";
			//ПараметрыПараметра.Анг = "x";
			//ПараметрыПараметра.Тип = ТипВещественное;
			//МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.activations.softsign";
			Объект = Перечисления.Нейро_ФункцииАктивации.softsign;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииАктивации.relu) Тогда
			АдресОбъекта = "relu";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Альфа";
			ПараметрыПараметра.Анг = "alpha";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Макс. значение";
			ПараметрыПараметра.Анг = "max_value";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Порог";
			ПараметрыПараметра.Анг = "threshold";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.activations.relu";
			Объект = Перечисления.Нейро_ФункцииАктивации.relu;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииАктивации.tanh) Тогда
			АдресОбъекта = "tanh";
			//ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			//ПараметрыПараметра.Рус = "x";
			//ПараметрыПараметра.Анг = "x";
			//ПараметрыПараметра.Тип = ТипВещественное;
			//МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.activations.tanh";
			Объект = Перечисления.Нейро_ФункцииАктивации.tanh;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииАктивации.sigmoid) Тогда
			АдресОбъекта = "sigmoid";
			//ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			//ПараметрыПараметра.Рус = "x";
			//ПараметрыПараметра.Анг = "x";
			//ПараметрыПараметра.Тип = ТипВещественное;
			//МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.activations.sigmoid";
			Объект = Перечисления.Нейро_ФункцииАктивации.sigmoid;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииАктивации.hard_sigmoid) Тогда //Segment-wise linear approximation of sigmoid.
			АдресОбъекта = "hard_sigmoid";
			//ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			//ПараметрыПараметра.Рус = "x";
			//ПараметрыПараметра.Анг = "x";
			//ПараметрыПараметра.Тип = ТипВещественное;
			//МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.activations.hard_sigmoid";
			Объект = Перечисления.Нейро_ФункцииАктивации.hard_sigmoid;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииАктивации.exponential) Тогда
			АдресОбъекта = "exponential";
			//ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			//ПараметрыПараметра.Рус = "x";
			//ПараметрыПараметра.Анг = "x";
			//ПараметрыПараметра.Тип = ТипВещественное;
			//МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.activations.exponential";
			Объект = Перечисления.Нейро_ФункцииАктивации.exponential;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииАктивации.linear) Тогда
			АдресОбъекта = "linear";
			//ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			//ПараметрыПараметра.Рус = "x";
			//ПараметрыПараметра.Анг = "x";
			//ПараметрыПараметра.Тип = ТипВещественное;
			//МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.activations.linear";
			Объект = Перечисления.Нейро_ФункцииАктивации.linear;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииАктивации.Прочее) Тогда
			Объект = Неопределено;
		КонецЕсли;
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, Доп, ИдОбъекта, Значение, Адрес",Значение.Синоним,Значение.Имя, ТипАктивация, МассивДоп, ИдОбъекта, Объект, АдресГруппы + АдресОбъекта));
		//Результат.Добавить(Новый Структура("Рус, Анг, Тип, Доп",Значение.Синоним,Значение.Имя, Тип("ПеречислениеСсылка.Нейро_ФункцииАктивации"),МассивДоп));
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция ПолучитьПараметрыИнициализации() Экспорт
	Результат = Новый Массив;

	ТипСтрока       = Перечисления.Нейро_Типы.Строка;
	ТипЦелое        = Перечисления.Нейро_Типы.Целое;
	ТипВещественное = Перечисления.Нейро_Типы.Вещественное;
	ТипБулево       = Перечисления.Нейро_Типы.ФункцияАктивации;
	ТипИнициализатор = Перечисления.Нейро_Типы.Инициализатор;
	
	АдресГруппы = "keras/initializers/"; 
	
	Для Сч = 0 По Метаданные.Перечисления.Нейро_Инициализаторы.ЗначенияПеречисления.Количество()-1 Цикл
		МассивДоп=Новый Массив;
		ИдОбъекта = ""; АдресОбъекта = "";
		Значение=Метаданные.Перечисления.Нейро_Инициализаторы.ЗначенияПеречисления[Сч];
		Если Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.zeros) Тогда
			АдресОбъекта = "Zeros";
			ИдОбъекта = "keras.initializers.Zeros";
			Объект = Перечисления.Нейро_Инициализаторы.zeros;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.ones) Тогда
			АдресОбъекта = "Ones";
			ИдОбъекта = "keras.initializers.Ones";
			Объект = Перечисления.Нейро_Инициализаторы.ones;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.constant) Тогда
			АдресОбъекта = "Constant";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Значение";
			ПараметрыПараметра.Анг = "value";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.initializers.Constant";
			Объект = Перечисления.Нейро_Инициализаторы.constant;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.random_normal) Тогда
			АдресОбъекта = "RandomNormal";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Среднее";
			ПараметрыПараметра.Анг = "mean";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Стандартное отклонение";
			ПараметрыПараметра.Анг = "stddev";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Инициализатор случайных чисел";
			ПараметрыПараметра.Анг = "seed";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.initializers.RandomNormal";
			Объект = Перечисления.Нейро_Инициализаторы.random_normal;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.random_uniform) Тогда
			АдресОбъекта = "RandomUniform";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Минимальное значение";
			ПараметрыПараметра.Анг = "minval";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Максимальное значение";
			ПараметрыПараметра.Анг = "maxval";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Инициализатор случайных чисел";
			ПараметрыПараметра.Анг = "seed";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.initializers.RandomUniform";
			Объект = Перечисления.Нейро_Инициализаторы.random_uniform;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.truncated_normal) Тогда
			АдресОбъекта = "TruncatedNormal";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Среднее";
			ПараметрыПараметра.Анг = "mean";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Стандартное отклонение";
			ПараметрыПараметра.Анг = "stddev";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Инициализатор случайных чисел";
			ПараметрыПараметра.Анг = "seed";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.initializers.TruncatedNormal";
			Объект = Перечисления.Нейро_Инициализаторы.truncated_normal;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.VarianceScaling) Тогда
			АдресОбъекта = "VarianceScaling";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Масштаб";
			ПараметрыПараметра.Анг = "scale";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Режим";
			ПараметрыПараметра.Анг = "mode"; //"fan_in", "fan_out", "fan_avg"
			ПараметрыПараметра.Тип = Перечисления.Нейро_Типы.VarianceScaling_Режим;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Распределение";
			ПараметрыПараметра.Анг = "distribution"; //"normal", "uniform"
			ПараметрыПараметра.Тип = Перечисления.Нейро_Типы.VarianceScaling_Распределение;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Инициализатор случайных чисел";
			ПараметрыПараметра.Анг = "seed";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.initializers.VarianceScaling";
			Объект = Перечисления.Нейро_Инициализаторы.VarianceScaling;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.orthogonal) Тогда
			АдресОбъекта = "Orthogonal";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Усиление";
			ПараметрыПараметра.Анг = "gain";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Инициализатор случайных чисел";
			ПараметрыПараметра.Анг = "seed";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.initializers.Orthogonal";
			Объект = Перечисления.Нейро_Инициализаторы.orthogonal;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.Identity) Тогда
			АдресОбъекта = "Identity";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Усиление";
			ПараметрыПараметра.Анг = "gain";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.initializers.Identity";
			Объект = Перечисления.Нейро_Инициализаторы.Identity;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.lecun_uniform) Тогда
			АдресОбъекта = "lecun_uniform";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Инициализатор случайных чисел";
			ПараметрыПараметра.Анг = "seed";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.initializers.lecun_uniform";
			Объект = Перечисления.Нейро_Инициализаторы.lecun_uniform;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.glorot_normal) Тогда
			АдресОбъекта = "GlorotNormal";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Инициализатор случайных чисел";
			ПараметрыПараметра.Анг = "seed";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.initializers.glorot_normal";
			Объект = Перечисления.Нейро_Инициализаторы.glorot_normal;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.glorot_uniform) Тогда
			АдресОбъекта = "GlorotUniform";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Инициализатор случайных чисел";
			ПараметрыПараметра.Анг = "seed";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.initializers.glorot_uniform";
			Объект = Перечисления.Нейро_Инициализаторы.glorot_uniform;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.he_normal) Тогда
			АдресОбъекта = "he_normal";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Инициализатор случайных чисел";
			ПараметрыПараметра.Анг = "seed";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.initializers.he_normal";
			Объект = Перечисления.Нейро_Инициализаторы.he_normal;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.lecun_normal) Тогда
			АдресОбъекта = "lecun_normal";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Инициализатор случайных чисел";
			ПараметрыПараметра.Анг = "seed";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.initializers.lecun_normal";
			Объект = Перечисления.Нейро_Инициализаторы.lecun_normal;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.he_uniform) Тогда
			АдресОбъекта = "he_uniform";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Инициализатор случайных чисел";
			ПараметрыПараметра.Анг = "seed";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.initializers.he_uniform";
			Объект = Перечисления.Нейро_Инициализаторы.he_uniform;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Инициализаторы.Прочее) Тогда
			Объект = Перечисления.Нейро_Инициализаторы.Прочее;
		КонецЕсли;
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, Доп, ИдОбъекта, Значение, Адрес",Значение.Синоним,Значение.Имя, ТипИнициализатор, МассивДоп, ИдОбъекта, Объект, АдресГруппы + АдресОбъекта));
		//Результат.Добавить(Новый Структура("Рус, Анг, Тип, Доп",Значение.Синоним,Значение.Имя, Тип("ПеречислениеСсылка.Нейро_ФункцииАктивации"),МассивДоп));
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция ПолучитьПараметрыРегуляризации() Экспорт
	Результат = Новый Массив;

	ТипСтрока       = Перечисления.Нейро_Типы.Строка;
	ТипЦелое        = Перечисления.Нейро_Типы.Целое;
	ТипВещественное = Перечисления.Нейро_Типы.Вещественное;
	ТипАктивация    = Перечисления.Нейро_Типы.ФункцияАктивации;
	ТипБулево       = Перечисления.Нейро_Типы.ФункцияАктивации;
	ТипРегуляризация = Перечисления.Нейро_Типы.Регуляризатор;
	
	АдресГруппы = "keras/regularizers/";
	
	Для Сч = 0 По Метаданные.Перечисления.Нейро_Регуляризаторы.ЗначенияПеречисления.Количество()-1 Цикл
		МассивДоп=Новый Массив;
		ИдОбъекта = ""; АдресОбъекта = "";
		Значение=Метаданные.Перечисления.Нейро_Регуляризаторы.ЗначенияПеречисления[Сч];
		Если Значение.Синоним=СокрЛП(Перечисления.Нейро_Регуляризаторы.l1) Тогда
			АдресОбъекта = "l1";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "l";
			ПараметрыПараметра.Анг = "l";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.regularizers.l1";
			Объект = Перечисления.Нейро_Регуляризаторы.l1;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Регуляризаторы.l2) Тогда
			АдресОбъекта = "l2";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "l";
			ПараметрыПараметра.Анг = "l";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.regularizers.l2";
			Объект = Перечисления.Нейро_Регуляризаторы.l2;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Регуляризаторы.l1_l2) Тогда
			АдресОбъекта = "l1_l2";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "l1";
			ПараметрыПараметра.Анг = "l1";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "l2";
			ПараметрыПараметра.Анг = "l2";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.regularizers.l1_l2";
			Объект = Перечисления.Нейро_Регуляризаторы.l1_l2;
		КонецЕсли;
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, Доп, ИдОбъекта, Значение, Адрес",Значение.Синоним,Значение.Имя, ТипРегуляризация, МассивДоп, ИдОбъекта, Объект, АдресГруппы + АдресОбъекта));
		//Результат.Добавить(Новый Структура("Рус, Анг, Тип, Доп",Значение.Синоним,Значение.Имя, Тип("ПеречислениеСсылка.Нейро_ФункцииАктивации"),МассивДоп));
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция ПолучитьПараметрыОграничителя() Экспорт
	Результат = Новый Массив;

	ТипСтрока       = Перечисления.Нейро_Типы.Строка;
	ТипЦелое        = Перечисления.Нейро_Типы.Целое;
	ТипВещественное = Перечисления.Нейро_Типы.Вещественное;
	ТипАктивация    = Перечисления.Нейро_Типы.ФункцияАктивации;
	ТипБулево       = Перечисления.Нейро_Типы.ФункцияАктивации;
	ТипОграничитель = Перечисления.Нейро_Типы.Ограничитель;
	
	АдресГруппы = "keras/constraints/";
	
	Для Сч = 0 По Метаданные.Перечисления.Нейро_Ограничители.ЗначенияПеречисления.Количество()-1 Цикл
		МассивДоп=Новый Массив;
		ИдОбъекта = ""; АдресОбъекта = "";
		Значение=Метаданные.Перечисления.Нейро_Ограничители.ЗначенияПеречисления[Сч];
		Если Значение.Синоним=СокрЛП(Перечисления.Нейро_Ограничители.max_norm) Тогда
			АдресОбъекта = "MaxNorm";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Максимальное значение";
			ПараметрыПараметра.Анг = "max_value";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Ось";
			ПараметрыПараметра.Анг = "axis";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.constraints.MaxNorm";
			Объект = Перечисления.Нейро_Ограничители.max_norm;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Ограничители.non_neg) Тогда
			АдресОбъекта = "NonNeg";
			ИдОбъекта = "keras.constraints.NonNeg";
			Объект = Перечисления.Нейро_Ограничители.non_neg;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Ограничители.unit_norm) Тогда
			АдресОбъекта = "UnitNorm";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Ось";
			ПараметрыПараметра.Анг = "axis";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.constraints.UnitNorm";
			Объект = Перечисления.Нейро_Ограничители.unit_norm;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Ограничители.min_max_norm) Тогда
			АдресОбъекта = "MinMaxNorm";
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Минимальное значение";
			ПараметрыПараметра.Анг = "min_value";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Максимальное значение";
			ПараметрыПараметра.Анг = "max_value";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Интенсивность";
			ПараметрыПараметра.Анг = "rate";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Ось";
			ПараметрыПараметра.Анг = "axis";
			ПараметрыПараметра.Тип = ТипЦелое;
			МассивДоп.Добавить(ПараметрыПараметра);
			ИдОбъекта = "keras.constraints.MinMaxNorm";
			Объект = Перечисления.Нейро_Ограничители.min_max_norm;
		ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Ограничители.RadialConstraint) Тогда
			АдресОбъекта = "RadialConstraint";
			ИдОбъекта = "keras.constraints.RadialConstraint";
			Объект = Перечисления.Нейро_Ограничители.RadialConstraint;
		КонецЕсли;
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, Доп, ИдОбъекта, Значение, Адрес",Значение.Синоним,Значение.Имя, ТипОграничитель, МассивДоп, ИдОбъекта, Объект, АдресГруппы + АдресОбъекта));
		//Результат.Добавить(Новый Структура("Рус, Анг, Тип, Доп",Значение.Синоним,Значение.Имя, Тип("ПеречислениеСсылка.Нейро_ФункцииАктивации"),МассивДоп));
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция ПолучитьПараметрыФункцииПотерь() Экспорт
	Результат = Новый Массив;

	ТипФПотерь      = Перечисления.Нейро_Типы.ФункцияПотерь;
	ТипТензор       = Перечисления.Нейро_Типы.Тензор;
	
	АдресГруппы = "keras/losses/";
	
	Для Сч = 0 По Метаданные.Перечисления.Нейро_ФункцииПотерь.ЗначенияПеречисления.Количество()-1 Цикл
		МассивДоп=Новый Массив;
		ИдОбъекта = ""; АдресОбъекта = "";
		Значение=Метаданные.Перечисления.Нейро_ФункцииПотерь.ЗначенияПеречисления[Сч];
		Если Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.Прочее) Тогда
			Объект = Перечисления.Нейро_ФункцииПотерь.Прочее;
		Иначе
			ИдОбъекта = Значение.Комментарий;
			//ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			//ПараметрыПараметра.Рус = "Верные значения";
			//ПараметрыПараметра.Анг = "y_true";
			//ПараметрыПараметра.Тип = ТипТензор;
			//МассивДоп.Добавить(ПараметрыПараметра);
			//ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			//ПараметрыПараметра.Рус = "Предсказания";
			//ПараметрыПараметра.Анг = "y_pred";
			//ПараметрыПараметра.Тип = ТипТензор;
			//МассивДоп.Добавить(ПараметрыПараметра);
			Объект = Перечисления["Нейро_ФункцииПотерь"][Значение.Имя];
			Если Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.mean_squared_error) Тогда
				АдресОбъекта = "MSE";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.mean_absolute_error) Тогда
				АдресОбъекта = "MAE";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.mean_absolute_percentage_error) Тогда
				АдресОбъекта = "MAPE";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.mean_squared_logarithmic_error) Тогда
				АдресОбъекта = "MSLE";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.squared_hinge) Тогда
				АдресОбъекта = "squared_hinge";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.hinge) Тогда
				АдресОбъекта = "hinge";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.categorical_hinge) Тогда
				АдресОбъекта = "categorical_hinge";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.logcosh) Тогда
				АдресОбъекта = "logcosh";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.categorical_crossentropy) Тогда
				АдресОбъекта = "categorical_crossentropy";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.sparse_categorical_crossentropy) Тогда
				АдресОбъекта = "sparse_categorical_crossentropy";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.binary_crossentropy) Тогда
				АдресОбъекта = "binary_crossentropy";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.kullback_leibler_divergence) Тогда
				АдресОбъекта = "KLD";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.poisson) Тогда
				АдресОбъекта = "poisson";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.cosine_proximity) Тогда
				АдресОбъекта = "cosine_similarity";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_ФункцииПотерь.Huber) Тогда
				АдресОбъекта = "Huber";
			КонецЕсли;
		КонецЕсли;
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, Доп, ИдОбъекта, Значение, Адрес",Значение.Синоним,Значение.Имя, ТипФПотерь, МассивДоп, ИдОбъекта, Объект, АдресГруппы + АдресОбъекта));
	КонецЦикла;
	
	Возврат Результат;
	
	//"""Binary crossentropy between an output tensor and a target tensor.

	//# Arguments
	//    target: A tensor with the same shape as `output`.
	//    output: A tensor.
	//    from_logits: Whether `output` is expected to be a logits tensor.
	//        By default, we consider that `output`
	//        encodes a probability distribution.
	
	
	
КонецФункции

Функция ПолучитьПараметрыМетрики() Экспорт
	Результат = Новый Массив;

	ТипФМетрика     = Перечисления.Нейро_Типы.Метрика;
	ТипТензор       = Перечисления.Нейро_Типы.Тензор;
	ТипЦелое        = Перечисления.Нейро_Типы.Целое;
	ТипВещественное = Перечисления.Нейро_Типы.Вещественное;
	
	АдресГруппы = "keras/metrics/";
	
	Для Сч = 0 По Метаданные.Перечисления.Нейро_Метрики.ЗначенияПеречисления.Количество()-1 Цикл
		МассивДоп=Новый Массив;
		ИдОбъекта = ""; АдресОбъекта = "";
		Значение=Метаданные.Перечисления.Нейро_Метрики.ЗначенияПеречисления[Сч];
		Если Значение.Синоним=СокрЛП(Перечисления.Нейро_Метрики.Прочее) Тогда
			Объект = Перечисления.Нейро_Метрики.Прочее;
		Иначе
			ИдОбъекта = Значение.Комментарий;
			//ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			//ПараметрыПараметра.Рус = "Верные значения";
			//ПараметрыПараметра.Анг = "y_true";
			//ПараметрыПараметра.Тип = ТипТензор;
			//МассивДоп.Добавить(ПараметрыПараметра);
			//ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			//ПараметрыПараметра.Рус = "Предсказания";
			//ПараметрыПараметра.Анг = "y_pred";
			//ПараметрыПараметра.Тип = ТипТензор;
			//МассивДоп.Добавить(ПараметрыПараметра);
			Если Значение.Синоним=СокрЛП(Перечисления.Нейро_Метрики.top_k_categorical_accuracy) Тогда
				АдресОбъекта = "top_k_categorical_accuracy";
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "K";
				ПараметрыПараметра.Анг = "K";
				ПараметрыПараметра.Тип = ТипЦелое;
				МассивДоп.Добавить(ПараметрыПараметра);
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Метрики.sparse_top_k_categorical_accuracy) Тогда
				АдресОбъекта = "sparse_top_k_categorical_accuracy";
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "K";
				ПараметрыПараметра.Анг = "K";
				ПараметрыПараметра.Тип = ТипЦелое;
				МассивДоп.Добавить(ПараметрыПараметра);
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Метрики.binary_accuracy) Тогда
				АдресОбъекта = "binary_accuracy";
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Порог";
				ПараметрыПараметра.Анг = "threshold";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Метрики.cosine_proximity) Тогда
				АдресОбъекта = "CosineSimilarity";
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Ось";
				ПараметрыПараметра.Анг = "axis";
				ПараметрыПараметра.Тип = ТипЦелое;
				МассивДоп.Добавить(ПараметрыПараметра);
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Метрики.accuracy) Тогда
				АдресОбъекта = "Accuracy";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Метрики.crossentropy) Тогда
				АдресОбъекта = "";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Метрики.categorical_accuracy) Тогда
				АдресОбъекта = "CategoricalAccuracy";
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Метрики.sparse_categorical_accuracy) Тогда
				АдресОбъекта = "sparse_categorical_accuracy";
			КонецЕсли;
			Объект = Перечисления["Нейро_Метрики"][Значение.Имя];
		КонецЕсли;
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, Доп, ИдОбъекта, Значение, Адрес",Значение.Синоним,Значение.Имя, ТипФМетрика, МассивДоп, ИдОбъекта, Объект, АдресГруппы + АдресОбъекта));
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция ПолучитьПараметрыОптимизатора() Экспорт
	Результат = Новый Массив;

	ТипОптимизатор     = Перечисления.Нейро_Типы.Оптимизатор;
	//ТипТензор       = Перечисления.Нейро_Типы.Тензор;
	ТипЦелое        = Перечисления.Нейро_Типы.Целое;
	ТипВещественное = Перечисления.Нейро_Типы.Вещественное;
	ТипБулево       = Перечисления.Нейро_Типы.Булево;
	
	АдресГруппы = "keras/optimizers/";
	
	Для Сч = 0 По Метаданные.Перечисления.Нейро_Оптимизаторы.ЗначенияПеречисления.Количество()-1 Цикл
		МассивДоп=Новый Массив;
		ИдОбъекта = ""; АдресОбъекта = "";
		Значение=Метаданные.Перечисления.Нейро_Оптимизаторы.ЗначенияПеречисления[Сч];
		Если Значение.Синоним=СокрЛП(Перечисления.Нейро_Оптимизаторы.Прочее) Тогда
			Объект = Перечисления.Нейро_Оптимизаторы.Прочее;
		Иначе
			ИдОбъекта = Значение.Комментарий;
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Обрезать градиенты по норме L2";
			ПараметрыПараметра.Анг = "clipnorm";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
			ПараметрыПараметра.Рус = "Обрезать градиенты до значения";
			ПараметрыПараметра.Анг = "clipvalue";
			ПараметрыПараметра.Тип = ТипВещественное;
			МассивДоп.Добавить(ПараметрыПараметра);
			Если Значение.Синоним=СокрЛП(Перечисления.Нейро_Оптимизаторы.SGD) Тогда
				АдресОбъекта = "SGD";
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Скорость обучения";
				ПараметрыПараметра.Анг = "lr";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Импульс";
				ПараметрыПараметра.Анг = "momentum";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Замедление";
				ПараметрыПараметра.Анг = "decay";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Импульс Нестерова";
				ПараметрыПараметра.Анг = "nesterov";
				ПараметрыПараметра.Тип = ТипБулево;
				МассивДоп.Добавить(ПараметрыПараметра);
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Оптимизаторы.RMSprop) Тогда
				АдресОбъекта = "RMSprop";
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Скорость обучения";
				ПараметрыПараметра.Анг = "lr";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "rho";
				ПараметрыПараметра.Анг = "rho";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Нечеткий фактор";
				ПараметрыПараметра.Анг = "epsilon";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Замедление";
				ПараметрыПараметра.Анг = "decay";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Оптимизаторы.Adagrad) Тогда
				АдресОбъекта = "Adagrad";
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Скорость обучения";
				ПараметрыПараметра.Анг = "lr";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Нечеткий фактор";
				ПараметрыПараметра.Анг = "epsilon";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Замедление";
				ПараметрыПараметра.Анг = "decay";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Оптимизаторы.Adadelta) Тогда
				АдресОбъекта = "Adadelta";
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Скорость обучения";
				ПараметрыПараметра.Анг = "lr";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "rho";
				ПараметрыПараметра.Анг = "rho";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Нечеткий фактор";
				ПараметрыПараметра.Анг = "epsilon";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Замедление";
				ПараметрыПараметра.Анг = "decay";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Оптимизаторы.Adam) Тогда
				АдресОбъекта = "Adam";
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Скорость обучения";
				ПараметрыПараметра.Анг = "lr";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "beta_1";
				ПараметрыПараметра.Анг = "beta_1";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "beta_2";
				ПараметрыПараметра.Анг = "beta_2";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Нечеткий фактор";
				ПараметрыПараметра.Анг = "epsilon";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Замедление";
				ПараметрыПараметра.Анг = "decay";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "AMSGrad";
				ПараметрыПараметра.Анг = "amsgrad";
				ПараметрыПараметра.Тип = ТипБулево;
				МассивДоп.Добавить(ПараметрыПараметра);
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Оптимизаторы.Adamax) Тогда
				АдресОбъекта = "Adamax";
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Скорость обучения";
				ПараметрыПараметра.Анг = "lr";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "beta_1";
				ПараметрыПараметра.Анг = "beta_1";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "beta_2";
				ПараметрыПараметра.Анг = "beta_2";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Нечеткий фактор";
				ПараметрыПараметра.Анг = "epsilon";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Замедление";
				ПараметрыПараметра.Анг = "decay";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Оптимизаторы.Nadam) Тогда
				АдресОбъекта = "Nadam";
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Скорость обучения";
				ПараметрыПараметра.Анг = "lr";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "beta_1";
				ПараметрыПараметра.Анг = "beta_1";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "beta_2";
				ПараметрыПараметра.Анг = "beta_2";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Нечеткий фактор";
				ПараметрыПараметра.Анг = "epsilon";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Плановое замедление";
				ПараметрыПараметра.Анг = "schedule_decay";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
			ИначеЕсли Значение.Синоним=СокрЛП(Перечисления.Нейро_Оптимизаторы.Ftrl) Тогда
				АдресОбъекта = "Ftrl";
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Скорость обучения";
				ПараметрыПараметра.Анг = "learning_rate";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Уменьшение скорости обучения";
				ПараметрыПараметра.Анг = "learning_rate_power";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Начальное значение для аккумуляторов";
				ПараметрыПараметра.Анг = "initial_accumulator_value";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Сила L1-регуляризации";
				ПараметрыПараметра.Анг = "l1_regularization_strength";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Сила L2-регуляризации";
				ПараметрыПараметра.Анг = "l2_regularization_strength";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Префикс имени";
				ПараметрыПараметра.Анг = "name";
				ПараметрыПараметра.Тип = Перечисления.Нейро_Типы.Строка;
				МассивДоп.Добавить(ПараметрыПараметра);
				ПараметрыПараметра = Новый Структура("Рус, Анг, Тип");
				ПараметрыПараметра.Рус = "Уменьшение силы L2-регуляризации";
				ПараметрыПараметра.Анг = "l2_shrinkage_regularization_strength";
				ПараметрыПараметра.Тип = ТипВещественное;
				МассивДоп.Добавить(ПараметрыПараметра);
			КонецЕсли;
			Объект = Перечисления["Нейро_Оптимизаторы"][Значение.Имя];
		КонецЕсли;
		Результат.Добавить(Новый Структура("Рус, Анг, Тип, Доп, ИдОбъекта, Значение, Адрес",Значение.Синоним,Значение.Имя, ТипОптимизатор, МассивДоп, ИдОбъекта, Объект, АдресГруппы + АдресОбъекта));
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

#КонецОбласти


Функция ПодобратьДлины(Предел, Коэф) Экспорт
	Для Сч=1 По Предел Цикл
		Если Окр(Сч+(Сч*Коэф))>=Предел Тогда
			Возврат Новый Структура("Длина1, Длина2", Сч, Сч*Коэф);
		КонецЕсли;
	КонецЦикла;
КонецФункции

Функция ПолучитьТипыСлояПоВидуСлоя(ВидСлоя) Экспорт
	СписокТиповСлоев = Новый СписокЗначений;
	
	Если ВидСлоя=Перечисления.Нейро_ВидыСлоев.Core Тогда                     // Основной
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Dense);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Activation);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Dropout);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Flatten);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.InputLayer);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Reshape);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Permute);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.RepeatVector);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.ActivityRegularization);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Masking);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.SpatialDropout1D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.SpatialDropout2D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.SpatialDropout3D);
		
	ИначеЕсли ВидСлоя=Перечисления.Нейро_ВидыСлоев.Convolutional Тогда       // Сверточный
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Conv1D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Conv2D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.SeparableConv1D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.SeparableConv2D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.DepthwiseConv2D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Conv2DTranspose);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Conv3D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Conv3DTranspose);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Cropping1D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Cropping2D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Cropping3D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.UpSampling1D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.UpSampling2D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.UpSampling3D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.ZeroPadding1D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.ZeroPadding2D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.ZeroPadding3D);
		                                                                     
	ИначеЕсли ВидСлоя=Перечисления.Нейро_ВидыСлоев.Pooling Тогда             // Подвыборка
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.MaxPooling1D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.MaxPooling2D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.MaxPooling3D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.AveragePooling1D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.AveragePooling2D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.AveragePooling3D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.GlobalMaxPooling1D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.GlobalAveragePooling1D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.GlobalMaxPooling2D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.GlobalAveragePooling2D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.GlobalMaxPooling3D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.GlobalAveragePooling3D);
		                                                                     
	ИначеЕсли ВидСлоя=Перечисления.Нейро_ВидыСлоев.LocallyСonnected Тогда    // ЛокальноСвязанный
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.LocallyConnected1D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.LocallyConnected2D);
		                                                                     
	ИначеЕсли ВидСлоя=Перечисления.Нейро_ВидыСлоев.Recurrent Тогда           // Рекуррентный
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.SimpleRNN);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.GRU);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.LSTM);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.ConvLSTM2D);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.ConvLSTM2DCell);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.SimpleRNNCell);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.GRUCell);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.LSTMCell);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.CuDNNGRU);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.CuDNNLSTM);
		                                                                     
	ИначеЕсли ВидСлоя=Перечисления.Нейро_ВидыСлоев.Embedding Тогда           // Встраивание
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Embedding);
		                                                                     
	ИначеЕсли ВидСлоя=Перечисления.Нейро_ВидыСлоев.Merge Тогда               // Слияние
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Add);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Subtract);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Multiply);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Average);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Maximum);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Minimum);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Concatenate);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Dot);
		                                                                     
	ИначеЕсли ВидСлоя=Перечисления.Нейро_ВидыСлоев.AdvancedActivations Тогда // АктивацияРасширенный
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.LeakyReLU);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.PReLU);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.ELU);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.ThresholdedReLU);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Softmax);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.ReLU);
		
	ИначеЕсли ВидСлоя=Перечисления.Нейро_ВидыСлоев.Normalization Тогда       // Нормализация
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.BatchNormalization);
		
	ИначеЕсли ВидСлоя=Перечисления.Нейро_ВидыСлоев.Noise Тогда               // Шум
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.GaussianNoise);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.GaussianDropout);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.AlphaDropout);
		
	ИначеЕсли ВидСлоя=Перечисления.Нейро_ВидыСлоев.LayerWrappers Тогда       // Оболочка
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.TimeDistributed);
		СписокТиповСлоев.Добавить(Перечисления.Нейро_ТипыСлоев.Bidirectional);
		
	КонецЕсли;	
	
	Возврат СписокТиповСлоев;
КонецФункции

#Область ПрограммныйТекст

Функция СформироватьПрограммныйТекстПоТипуЗначения(Идентификатор, Значение) Экспорт
	Тип = Неопределено;
	Если ТипЗнч(Значение)=Тип("СправочникСсылка.Нейро_Массивы") Тогда       // массив
		Тип = Перечисления.Нейро_Типы.Массив;
	ИначеЕсли ТипЗнч(Значение)=Тип("СправочникСсылка.Нейро_Функции") Тогда  // функция
		Тип = Перечисления.Нейро_Типы.Функция;
    КонецЕсли;
	Возврат СформироватьПрограммныйТекстИзЗначения(Идентификатор, Тип, Значение)
КонецФункции

Функция СформироватьПрограммныйТекстИзЗначения(Идентификатор, Тип, Значение) Экспорт
	Результат = ?(Идентификатор="","",Идентификатор+" = ");
	
	Если Значение=Неопределено И Тип<>Перечисления.Нейро_Типы.Неопределено Тогда                // Неопределено
		Возврат Результат+"None";
	КонецЕсли;
	
	Если ТипЗнч(Значение)=Тип("СправочникСсылка.Нейро_Массивы") Тогда       // массив
		Возврат Результат+СформироватьПрограммныйТекстИзМассива(Значение);
	ИначеЕсли ТипЗнч(Значение)=Тип("СправочникСсылка.Нейро_Функции") Тогда  // функция
		Возврат Результат+СформироватьПрограммныйТекстИзФункции(Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Массив Тогда                      // массив
		Возврат Результат+СформироватьПрограммныйТекстИзМассива(Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Целое Тогда                       // целое
		Возврат Результат+СтрЗаменить(Окр(Значение),Символы.НПП,"");
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Вещественное Тогда                // Вещественное
		Вещественное=СтрЗаменить(Значение,",",".");
		Результат=Результат+СтрЗаменить(Вещественное,Символы.НПП,"");
		Возврат Результат+?(Значение=Окр(Значение),".","");
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Строка Тогда                      // строка
		Возврат Результат+"'"+Значение+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Функция Тогда                     // функция
		Возврат Результат+СформироватьПрограммныйТекстИзФункции(Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.ФункцияАктивации Тогда            // ФункцияАктивации
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_ФункцииАктивации", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Инициализатор Тогда               // Инициализатор
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_Инициализаторы", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Регуляризатор Тогда               // Регуляризатор
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_Регуляризаторы", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Ограничитель Тогда                // Ограничитель
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_Ограничители", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.ФункцияПотерь Тогда               // ФункцияПотерь
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_ФункцииПотерь", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Метрика Тогда                     // Метрика
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_Метрики", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Оптимизатор Тогда                 // Оптимизатор
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_Оптимизаторы", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.ПорядокКаналов Тогда              // ПорядокКаналов
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_ПорядокКаналов", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.VarianceScaling_Распределение Тогда
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_VarianceScaling_Распределение", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.VarianceScaling_Режим Тогда
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_VarianceScaling_Режим", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.ТипNumPy Тогда
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_ТипыNumPy", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Булево Тогда                      // Булево
		Возврат Результат+?(Значение=Истина,"True","False");
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Неопределено Тогда                // Неопределено
		Возврат Результат+"None";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Заполнение Тогда
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_Padding", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.ЗаполнениеСокр Тогда
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_PaddingS", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Апскейлинг Тогда
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_Upscaling", Значение)+"'";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Слой Тогда
		Возврат Результат+"'"+ПолучитьИмяИзЗначенияПеречисления("Нейро_ТипыСлоев", Значение)+"'";
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

Функция СформироватьПрограммныйТекстИзМассива(Значение)
	Если Значение.ТипСписка=Перечисления.Нейро_ТипыСписков.Список Тогда
		Открывающая="["; Закрывающая="]";
	ИначеЕсли Значение.ТипСписка=Перечисления.Нейро_ТипыСписков.Кортеж Тогда
		Открывающая="("; Закрывающая=")";
	ИначеЕсли Значение.ТипСписка=Перечисления.Нейро_ТипыСписков.Словарь Тогда
		Открывающая="{"; Закрывающая="}";
	Иначе
		Возврат Неопределено
	КонецЕсли;
	Результат=Открывающая;
	Для Каждого СтрокаТЧ Из Значение.ЭлементыСписка Цикл
		Если Значение.ТипСписка=Перечисления.Нейро_ТипыСписков.Словарь Тогда
			Ключ=СтрокаТЧ.Ключ+"=";
		Иначе
			Ключ="";
		КонецЕсли;
		Если ЗначениеЗаполнено(СтрокаТЧ.Тип) Тогда
			ПрограммныйТекстИзЗначения = СформироватьПрограммныйТекстИзЗначения("", СтрокаТЧ.Тип, СтрокаТЧ.Значение);
		Иначе
			ПрограммныйТекстИзЗначения = ""
		КонецЕсли;
		//Результат=Результат+Ключ
		//			+?(СтрокаТЧ.Значение=Неопределено,"",СформироватьПрограммныйТекстИзЗначения("", СтрокаТЧ.Тип, СтрокаТЧ.Значение))+", ";
		Результат=Результат+Ключ+ПрограммныйТекстИзЗначения+", ";
	КонецЦикла;
	Результат=СокрЛП(Результат);
	Если Прав(Результат,1)="," Тогда
		Результат=Лев(Результат,СтрДлина(Результат)-1)
	КонецЕсли;
	Результат=Результат+Закрывающая;
	Возврат Результат;
КонецФункции

Функция СформироватьПрограммныйТекстИзФункции(Значение)
	Результат=Значение.Идентификатор;
	МассивТекстаПараметров = Новый Массив;
	Для Каждого СтрокаТЧ Из Значение.Параметры Цикл
		//Если СтрокаТЧ.Значение<>Неопределено Тогда
		Если СтрокаТЧ.Использование Тогда
			МассивТекстаПараметров.Добавить(СформироватьПрограммныйТекстИзЗначения(СтрокаТЧ.Ид, СтрокаТЧ.Тип, СтрокаТЧ.Значение));
		КонецЕсли;
	КонецЦикла;
	Результат=Результат+"(";
	Если МассивТекстаПараметров.Количество()>0 Тогда
		Для Каждого СтрокаТекста Из МассивТекстаПараметров Цикл
			Результат=Результат+СтрокаТекста+", ";
		КонецЦикла;
		Результат=СокрЛП(Результат);
		Если Прав(Результат,1)="," Тогда
			Результат=Лев(Результат,СтрДлина(Результат)-1)
		КонецЕсли;
	КонецЕсли;
	Результат=Результат+")";
	Возврат Результат;
КонецФункции

Функция ПосчитатьКоличествоСлоевКомпоновки(Объект) Экспорт
	Результат = 0;
	Для Каждого СтрокаТЧ Из Объект.Слои Цикл
		Если ТипЗнч(СтрокаТЧ.Слой) = Тип("СправочникСсылка.Нейро_Слои") Тогда
			Результат=Результат+1;
		ИначеЕсли ТипЗнч(СтрокаТЧ.Слой) = Тип("СправочникСсылка.Нейро_ПодключенныеМодели") Тогда
			Дерево=Новый ДеревоЗначений;
			Дерево.Колонки.Добавить("Свойство");
			Дерево.Колонки.Добавить("Значение");
			Дерево.Колонки.Добавить("Тип");
			Нейро_СозданиеМоделиНаСервере.ОбработатьМодельИзСтрокиJSON(СтрокаТЧ.Слой.ТекстМоделиJSON, Дерево);
			СтруктураМодели = Нейро_СозданиеМоделиНаСервере.ПеребратьОбъектJSON(Дерево);
			Результат = Результат + ПосчитатьКоличествоСлоевМодели(СтруктураМодели.config.layers);
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ПосчитатьКоличествоСлоевМодели(МассивСлоев)
	Результат = 0;
	Для Каждого СтруктураСлоя Из МассивСлоев Цикл
		Если СтруктураСлоя.class_name = "Model" Тогда
			Результат = Результат + ПосчитатьКоличествоСлоевМодели(СтруктураСлоя.config.layers)
		Иначе
			Результат = Результат + 1;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область ПолучитьТекстыИзЗначенийДляМетрик

Функция ПолучитьТекстИзЗНачения(Тип, Значение) Экспорт
	Если ТипЗнч(Значение)=Тип("СправочникСсылка.Нейро_Массивы") Тогда       // массив
		Возврат ПолучитьТекстыИзМассива(Значение);
	ИначеЕсли ТипЗнч(Значение)=Тип("СправочникСсылка.Нейро_Функции") Тогда  // функция
		Возврат ПолучитьТекстИзФункции(Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Массив Тогда                      // массив
		Возврат ПолучитьТекстыИзМассива(Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Целое Тогда                       // целое
		Возврат СтрЗаменить(Окр(Значение),Символы.НПП,"");
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Вещественное Тогда                // Вещественное
		Вещественное=СтрЗаменить(Значение,",",".");
		Результат=СтрЗаменить(Вещественное,Символы.НПП,"");
		Возврат Результат+?(Значение=Окр(Значение),".","");
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Строка Тогда                      // строка
		Возврат Значение;
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Функция Тогда                     // функция
		Возврат ПолучитьТекстИзФункции(Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.ФункцияАктивации Тогда            // ФункцияАктивации
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_ФункцииАктивации", Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Инициализатор Тогда               // Инициализатор
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_Инициализаторы", Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Регуляризатор Тогда               // Регуляризатор
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_Регуляризаторы", Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Ограничитель Тогда                // Ограничитель
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_Ограничители", Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.ФункцияПотерь Тогда               // ФункцияПотерь
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_ФункцииПотерь", Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Метрика Тогда                     // Метрика
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_Метрики", Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Оптимизатор Тогда                 // Оптимизатор
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_Оптимизаторы", Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.ПорядокКаналов Тогда              // ПорядокКаналов
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_ПорядокКаналов", Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.VarianceScaling_Распределение Тогда
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_VarianceScaling_Распределение", Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.VarianceScaling_Режим Тогда
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_VarianceScaling_Режим", Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.ТипNumPy Тогда
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_ТипыNumPy", Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Булево Тогда                      // Булево
		Возврат ?(Значение=Истина,"True","False");
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Неопределено Тогда                // Неопределено
		Возврат "None";
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Заполнение Тогда
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_Padding", Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.ЗаполнениеСокр Тогда
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_PaddingS", Значение);
	ИначеЕсли Тип=Перечисления.Нейро_Типы.Апскейлинг Тогда
		Возврат ПолучитьИмяИзЗначенияПеречисления("Нейро_Upscaling", Значение);
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

Функция ПолучитьТекстыИзМассива(Знач Значение) Экспорт
	Результат = Новый Массив;
	Для Каждого СтрокаТЧ Из Значение.ЭлементыСписка Цикл
		Если ЗначениеЗаполнено(СтрокаТЧ.Тип) Тогда
			РезультатЗначения = ПолучитьТекстИзЗНачения(СтрокаТЧ.Тип, СтрокаТЧ.Значение);
			Если ТипЗнч(РезультатЗначения)=ТИп("Массив") Тогда
				Для Каждого Значение Из РезультатЗначения Цикл
					Результат.Добавить(Значение);
				КонецЦикла;
			Иначе
				Результат.Добавить(РезультатЗначения);
			КонецЕсли;	
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ПолучитьТекстИзФункции(Знач Значение)
	Возврат ПолучитьТекстИзЗНачения(Значение.Тип, Значение.Значение);
	//Результат=Значение.Идентификатор;
	//МассивТекстаПараметров = Новый Массив;
	//Для Каждого СтрокаТЧ Из Значение.Параметры Цикл
	//	//Если СтрокаТЧ.Значение<>Неопределено Тогда
	//	Если СтрокаТЧ.Использование Тогда
	//		МассивТекстаПараметров.Добавить(СформироватьПрограммныйТекстИзЗначения(СтрокаТЧ.Ид, СтрокаТЧ.Тип, СтрокаТЧ.Значение));
	//	КонецЕсли;
	//КонецЦикла;
	//Если МассивТекстаПараметров.Количество()>0 Тогда
	//	Результат=Результат+"(";
	//	Для Каждого СтрокаТекста Из МассивТекстаПараметров Цикл
	//		Результат=Результат+СтрокаТекста+", ";
	//	КонецЦикла;
	//	Результат=СокрЛП(Результат);
	//	Если Прав(Результат,1)="," Тогда
	//		Результат=Лев(Результат,СтрДлина(Результат)-1)
	//	КонецЕсли;
	//	Результат=Результат+")";
	//КонецЕсли;
	//Возврат Результат;
КонецФункции

#КонецОбласти

//Функция ВыгрузитьДанныеФормыКоллекцияВТЗ(ТаблицаФормы) Экспорт
//	Возврат Новый ХранилищеЗначения(ТаблицаФормы.Выгрузить());
//КонецФункции

Функция ПолучитьРеквизитСлоя(Слой, ИмяРеквизита) Экспорт
	Возврат Слой[ИмяРеквизита];
КонецФункции

Функция ПолучитьРеквизитПоСсылке(Ссылка, ИмяРеквизита) Экспорт
	Возврат Ссылка[ИмяРеквизита];
КонецФункции

Функция СкопироватьРеквизитыОбъекта(Объект) Экспорт
	МетаданныеОбъекта = Метаданные.НайтиПоТипу(ТипЗнч(Объект));
	Результат = Новый Структура;
	Для каждого Реквизит из МетаданныеОбъекта.Реквизиты Цикл
		Результат.Вставить(Реквизит.Имя)
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Объект);
	Возврат Результат;
КонецФункции

Функция СкопироватьТЧОбъекта(Объект, ИмяТЧ) Экспорт
	МетаданныеОбъекта = Метаданные.НайтиПоТипу(ТипЗнч(Объект));
	Результат = Новый Массив;
	Реквизиты=Новый Структура;
	Для Каждого ТЧ из МетаданныеОбъекта.ТабличныеЧасти Цикл
		Если ИмяТЧ<>ТЧ.Имя Тогда 
			Продолжить;
		Иначе
			Для Каждого Реквизит из ТЧ.Реквизиты Цикл
				Реквизиты.Вставить(Реквизит.Имя)
			КонецЦикла;
			Прервать
		КонецЕсли;
	КонецЦикла;
	Если Реквизиты.Количество()=0 Тогда Возврат Неопределено КонецЕсли;
	Для Каждого СтрокаТЧ Из Объект[ИмяТЧ] Цикл
		Реквизит = Новый Структура;
		Для Каждого КлючИЗначение Из Реквизиты Цикл
			Реквизит.Вставить(КлючИЗначение.Ключ, СтрокаТЧ[КлючИЗначение.Ключ])
		КонецЦикла;
		Результат.Добавить(Реквизит);
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ТабЧастьВМассивСтруктур(Ссылка, ИмяТч) Экспорт
	Результат = Новый Массив;
	ТзКолонки = Ссылка[ИмяТч].ВыгрузитьКолонки();
	Для Каждого Колонка Из Ссылка[ИмяТч] Цикл
		СтруктураКолонки = Новый Структура;
		Для Каждого КолонкаТЧ Из ТзКолонки.Колонки Цикл
			СтруктураКолонки.Вставить(КолонкаТЧ.Имя, Колонка[КолонкаТЧ.Имя]);
		КонецЦикла;
		Результат.Добавить(СтруктураКолонки);
	КонецЦикла;
	Возврат Результат
КонецФункции
	
Функция ПолучитьИнформациюОСловаре(ИмяФайла) Экспорт
	
КонецФункции

Функция НайтиТипСлояПоИдентификатору(Идентификатор)
	Для Каждого Значение Из Метаданные.Перечисления.Нейро_ТипыСлоев.ЗначенияПеречисления Цикл
		Если Идентификатор=Перечисления.Нейро_ТипыСлоев[Значение.Имя] Тогда
			Возврат Значение.Комментарий;
		КонецЕсли;
	КонецЦикла;
	Возврат "";
	
КонецФункции

Функция ПреобразоватьСтрокуСловаряJSON0(СтрокаJSON1) Экспорт
	СтрокаJSON1=Сред(СтрокаJSON1,2,СтрДлина(СтрокаJSON1)-2);
	КоличествоЮСимволов=СтрЧислоВхождений(СтрокаJSON1,"\\\\u");
	Поз=0; НовСтр="";
	Если КоличествоЮСимволов>0 Тогда
		Поз=СтрНайти(СтрокаJSON1,"\\\\u",,1);
		СтрСЧ16=ЧислоИзШестнадцатеричнойСтроки("0x"+Сред(СтрокаJSON1,Поз+5, 4));
		НовСтр=Лев(СтрокаJSON1,Поз-1)+Символ(СтрСЧ16);
	КонецЕсли;
	Для Сч=1 По КоличествоЮСимволов-1 Цикл
		Поз1=СтрНайти(СтрокаJSON1,"\\\\u",,Поз+1);
		Если Поз1=0 Тогда Прервать КонецЕсли;
		СтрСЧ16=ЧислоИзШестнадцатеричнойСтроки("0x"+Сред(СтрокаJSON1,Поз1+5, 4));
		НовСтр=НовСтр+Сред(СтрокаJSON1,Поз+9, Поз1-Поз-9)+Символ(СтрСЧ16);
		Поз=Поз1; ПредПоз=Поз1+9;
	КонецЦикла;
	НовСтр=НовСтр+Прав(СтрокаJSON1, Стрдлина(СтрокаJSON1)-Поз1-8);
	НовСтр = СтрЗаменить(НовСтр,"\"+Символ(34),Символ(34));
	СтрокаФильтры=Символ(34)+"filters"+Символ(34)+": "+Символ(34);
	Поз = СтрНайти(НовСтр,СтрокаФильтры);
	Если Поз=0 Тогда Возврат "" КонецЕсли; Режим=0;
	Поз1=0;
	ЛеваяЧасть=Лев(НовСтр, Поз-1)+СтрокаФильтры;
	СредЧасть="";
	Для Сч=Поз+СтрДлина(СтрокаФильтры) По СтрДлина(НовСтр) Цикл
		ТекСим=Сред(НовСтр,Сч,1);
		Если ТекСим=Символ(34) И Режим=0 Тогда
			Поз1=Сч; Прервать
		КонецЕсли;
		Если Режим=2 Тогда Режим=0 КонецЕсли;
		Если ТекСим="\" Тогда
			Если Режим=0 Тогда
				Режим=1
			ИначеЕсли Режим=1 Тогда
				Режим=2
			КонецЕсли;
		КонецЕсли;
		Если Режим=0 Или Режим=2 Тогда
			СредЧасть=СредЧасть+ТекСим;
		КонецЕсли;
	КонецЦикла;
	Если Поз1=0 Тогда Возврат "" КонецЕсли; Режим=0;
	ПраваяЧасть = Прав(НовСтр,Стрдлина(НовСтр)-Поз1+1);
	ПраваяЧасть=СтрЗаменить(ПраваяЧасть,"\\"+Символ(34),Символ(34));
	СтрокаJSON1=ЛеваяЧасть+СредЧасть+ПраваяЧасть;
	
	Скобок=СтрЧислоВхождений(СтрокаJSON1,Символ(34)+"{");
	Для Сч=1 По Скобок Цикл
		поз = СтрНайти(СтрокаJSON1,Символ(34)+"{");
		поз2= СтрНайти(СтрокаJSON1,"}"+Символ(34),,поз+1);
		Если поз=0 И поз2=0 Тогда Прервать КонецЕсли;
		Если поз=0 Или поз2=0 Тогда Возврат "" КонецЕсли;
		СтрокаJSON1=Лев(СтрокаJSON1,Поз-1)+Прав(СтрокаJSON1,СтрДлина(СтрокаJSON1)-Поз);
		СтрокаJSON1=Лев(СтрокаJSON1,Поз2-1)+Прав(СтрокаJSON1,СтрДлина(СтрокаJSON1)-Поз2);
	КонецЦикла;
	
	Возврат СтрокаJSON1
КонецФункции

Функция ПреобразоватьСтрокуСловаряJSON(СтрокаJSON1) Экспорт
	СтрокаJSON1=Сред(СтрокаJSON1,2,СтрДлина(СтрокаJSON1)-2);
	КоличествоСимволов=СтрЧислоВхождений(СтрокаJSON1,"\\\\u");
	Если КоличествоСимволов>0 Тогда
		Поз=0; НовСтр="";
		МасТекстов = Новый Массив(КоличествоСимволов+1);
		Поз=СтрНайти(СтрокаJSON1,"\\\\u",,1);
		МасТекстов[0]=Лев(СтрокаJSON1,Поз-1)+Символ(ЧислоИзШестнадцатеричнойСтроки("0x"+Сред(СтрокаJSON1,Поз+5, 4)));
		Для Сч=1 По КоличествоСимволов-1 Цикл
			Поз1=СтрНайти(СтрокаJSON1,"\\\\u",,Поз+1);
			Если Поз1=0 Тогда Прервать КонецЕсли;
			МасТекстов[Сч]=Сред(СтрокаJSON1,Поз+9, Поз1-Поз-9)+Символ(ЧислоИзШестнадцатеричнойСтроки("0x"+Сред(СтрокаJSON1,Поз1+5, 4)));
			Поз=Поз1;
		КонецЦикла;
		МасТекстов[КоличествоСимволов] = Прав(СтрокаJSON1, Стрдлина(СтрокаJSON1)-Поз1-8);
		НовСтр=СтрСоединить(МасТекстов,"");
	Иначе
		НовСтр=СтрокаJSON1;
	КонецЕсли;
	НовСтр = СтрЗаменить(НовСтр,"\"+Символ(34),Символ(34));
	СтрокаФильтры=Символ(34)+"filters"+Символ(34)+": "+Символ(34);
	Поз = СтрНайти(НовСтр,СтрокаФильтры);
	Если Поз=0 Тогда Возврат "" КонецЕсли; Режим=0;
	Поз1=0;
	ЛеваяЧасть=Лев(НовСтр, Поз-1)+СтрокаФильтры;
	СредЧасть="";
	Для Сч=Поз+СтрДлина(СтрокаФильтры) По СтрДлина(НовСтр) Цикл
		ТекСим=Сред(НовСтр,Сч,1);
		Если ТекСим=Символ(34) И Режим=0 Тогда
			Поз1=Сч; Прервать
		КонецЕсли;
		Если Режим=2 Тогда Режим=0 КонецЕсли;
		Если ТекСим="\" Тогда
			Если Режим=0 Тогда
				Режим=1
			ИначеЕсли Режим=1 Тогда
				Режим=2
			КонецЕсли;
		КонецЕсли;
		Если Режим=0 Или Режим=2 Тогда
			СредЧасть=СредЧасть+ТекСим;
		КонецЕсли;
	КонецЦикла;
	Если Поз1=0 Тогда Возврат "" КонецЕсли; Режим=0;
	ПраваяЧасть = Прав(НовСтр,Стрдлина(НовСтр)-Поз1+1);
	ПраваяЧасть=СтрЗаменить(ПраваяЧасть,"\\"+Символ(34),Символ(34));
	СтрокаJSON1=ЛеваяЧасть+СредЧасть+ПраваяЧасть;
	
	Скобок=СтрЧислоВхождений(СтрокаJSON1,Символ(34)+"{");
	Для Сч=1 По Скобок Цикл
		поз = СтрНайти(СтрокаJSON1,Символ(34)+"{");
		поз2= СтрНайти(СтрокаJSON1,"}"+Символ(34),,поз+1);
		Если поз=0 И поз2=0 Тогда Прервать КонецЕсли;
		Если поз=0 Или поз2=0 Тогда Возврат "" КонецЕсли;
		СтрокаJSON1=Лев(СтрокаJSON1,Поз-1)+Прав(СтрокаJSON1,СтрДлина(СтрокаJSON1)-Поз);
		СтрокаJSON1=Лев(СтрокаJSON1,Поз2-1)+Прав(СтрокаJSON1,СтрДлина(СтрокаJSON1)-Поз2);
	КонецЦикла;
	
	Возврат СтрокаJSON1
КонецФункции

Функция ПолучитьИдентификаторИзРегистра(Имя) Экспорт
	НаборЗаписей = РегистрыСведений.Нейро_Идентификаторы.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Имя.Установить(Имя);
	НаборЗаписей.Прочитать();
	Если НаборЗаписей.Количество() > 0 Тогда
		Возврат НаборЗаписей[0].Значение;
	КонецЕсли;
	Возврат "";
КонецФункции

Функция ПолучитьНастройку(ИмяНастройки) Экспорт
	НаборЗаписей = РегистрыСведений.Нейро_Настройки.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Имя.Установить(ИмяНастройки);
	НаборЗаписей.Прочитать();
	Если НаборЗаписей.Количество() = 0 Тогда
		Возврат Неопределено
	Иначе
		Возврат НаборЗаписей[0].Значение
	КонецЕсли;
КонецФункции

Функция УстановитьНастройку(ИмяНастройки, Значение) Экспорт
	НаборЗаписей = РегистрыСведений.Нейро_Настройки.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Имя.Установить(ИмяНастройки);
	НаборЗаписей.Прочитать();
	Если НаборЗаписей.Количество() = 0 Тогда
		НовыйНомер = НаборЗаписей.Добавить();
		НовыйНомер.Имя = ИмяНастройки;
	Иначе
		НовыйНомер = НаборЗаписей[0];
	КонецЕсли;
	Если НовыйНомер.Значение<>Значение Тогда
		НовыйНомер.Значение = Значение;
		НаборЗаписей.Записать();
	КонецЕсли;
КонецФункции

Функция УстановитьИдентификатор(ИмяИдентификатора, Значение) Экспорт
	НаборЗаписей = РегистрыСведений.Нейро_Идентификаторы.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Имя.Установить(ИмяИдентификатора);
	НаборЗаписей.Прочитать();
	Если НаборЗаписей.Количество() = 0 Тогда
		НовыйНомер = НаборЗаписей.Добавить();
		НовыйНомер.Имя = ИмяИдентификатора;
	Иначе
		НовыйНомер = НаборЗаписей[0];
	КонецЕсли;
	Если НовыйНомер.Значение<>Значение Тогда
		НовыйНомер.Значение = Значение;
		НаборЗаписей.Записать();
	КонецЕсли;
КонецФункции

Функция МассивОсновныхИсключенийПитон() Экспорт
	Результат = Новый Массив;
	Результат.Добавить("AttributeError");    //объект не имеет данного атрибута (значения или метода)
	Результат.Добавить("IOError");
	Результат.Добавить("ImportError");       //оператор import не может найти определение модуля, или имя файла
	Результат.Добавить("KeyboardInterrupt"); //пользователь нажимает клавишу прерывания(обычно Delete или Ctrl+C);
	Результат.Добавить("TypeError");         //операция или функция применяется к объекту несоответствующего типа. Связанное значение представляет собой строку, в которой приводятся подробные сведения о несоответствии типов;
	Результат.Добавить("ValueError");        //встроенная операция или функция получают аргумент, тип которого правильный, но неправильно значение
	
	Результат.Добавить("ArithmeticError");
	Результат.Добавить("FloatingPointError");
	Результат.Добавить("OverflowError");
	Результат.Добавить("ZeroDivisionError"); //второй аргумент операции division или modulo равен нулю;
	
	Результат.Добавить("BufferError");
	Результат.Добавить("EOFError");
	
	Результат.Добавить("LookupError");       //некорректный индекс или ключ
	Результат.Добавить("KeyError");          //ключ сопоставления (dictionary key) не найден в наборе существующих ключей;
	Результат.Добавить("IndexError");        //индекс последовательности находится вне допустимого диапазона;
	
	Результат.Добавить("MemoryError");
	
	Результат.Добавить("NameError");         //локальное или глобальное имя не найдено;
	Результат.Добавить("UnboundLocalError"); //сделана ссылка на локальную переменную в функции, но переменная не определена ранее
	
	Результат.Добавить("OSError");           //функция получает связанную с системой ошибку;
	Результат.Добавить("BlockingIOError");
	Результат.Добавить("ChildProcessError"); //неудача при операции с дочерним процессом.
	Результат.Добавить("BrokenPipeError"); //
	Результат.Добавить("ConnectionAbortedError"); //
	Результат.Добавить("ConnectionRefusedError"); //
	Результат.Добавить("ConnectionResetError"); //
	Результат.Добавить("FileExistsError"); //попытка создания файла или директории, которая уже существует.
	Результат.Добавить("FileNotFoundError"); //файл или директория не существует.
	Результат.Добавить("InterruptedError"); //системный вызов прерван входящим сигналом.
	Результат.Добавить("IsADirectoryError"); //ожидался файл, но это директория.
	Результат.Добавить("NotADirectoryError"); //ожидалась директория, но это файл.
	Результат.Добавить("PermissionError"); //не хватает прав доступа.
	Результат.Добавить("ProcessLookupError"); //указанного процесса не существует.
	Результат.Добавить("TimeoutError"); //закончилось время ожидания.
	
	Результат.Добавить("ReferenceError"); //попытка доступа к атрибуту со слабой ссылкой.
	Результат.Добавить("RuntimeError"); //возникает, когда исключение не попадает ни под одну из других категорий.
	Результат.Добавить("NotImplementedError"); //возникает, когда абстрактные методы класса требуют переопределения в дочерних классах.
	
	Результат.Добавить("SyntaxError");       
	Результат.Добавить("IndentationError"); //неправильные отступы.
	Результат.Добавить("TabError"); //смешивание в отступах табуляции и пробелов.
	
	Результат.Добавить("SystemError"); //внутренняя ошибка.
	
	Результат.Добавить("UnicodeError"); //ошибка, связанная с кодированием / раскодированием unicode в строках.
	Результат.Добавить("UnicodeEncodeError"); //исключение, связанное с кодированием unicode.
	Результат.Добавить("UnicodeDecodeError"); //исключение, связанное с декодированием unicode.
	Результат.Добавить("UnicodeTranslateError"); //исключение, связанное с переводом unicode.	
	
	Возврат Результат;
КонецФункции

Функция ИнформацияОПрограмме() Экспорт
	Результат = Новый Структура("Версия, Пользователь, Контакты", "","","");
	
	Результат.Пользователь = "";
	
	МассивРасширений = РасширенияКонфигурации.Получить(Новый Структура("Имя", "НейроКонструктор"));
	СтрокаВерсия = "";
	Для Каждого Расширение Из МассивРасширений Цикл
		Если Не Расширение.Активно Тогда Продолжить КонецЕсли;
		Если СтрокаВерсия<>"" Тогда СтрокаВерсия=СтрокаВерсия+"; " КонецЕсли;
		СтрокаВерсия=СтрокаВерсия+СокрЛП(Расширение.Версия);
	КонецЦикла;
	Результат.Версия = СтрокаВерсия;
	Возврат Результат;
КонецФункции

Функция ИдИмпортKeras() Экспорт
	Если Нейро_ОбщийМодуль.ПолучитьНастройку("ИспользоватьВстроенныйKeras") Тогда
		Возврат 
	    "import tensorflow.keras as keras"
		//"import tensorflow as tf; import tf.keras as keras"
	Иначе
		Возврат "import keras"
	КонецЕсли;
КонецФункции

Функция ИдFromKeras(ТекстИд) Экспорт
	Если Нейро_ОбщийМодуль.ПолучитьНастройку("ИспользоватьВстроенныйKeras") Тогда
		Результат = СтрЗаменить(ТекстИд,"from keras.","from tensorflow.keras.");
		Возврат СтрЗаменить(Результат,"from keras ","from tensorflow.keras ");
	Иначе
		Возврат ТекстИд
	КонецЕсли;
КонецФункции
